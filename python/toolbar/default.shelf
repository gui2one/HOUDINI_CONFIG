<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <tool name="SideFX::toonsimple" orbolt="True" label="Toon Simple" icon="SideFX__toonsimple-icon.png">
    <helpText><![CDATA[Install or download the Toon Simple Orbolt digital asset.]]></helpText>
    <helpURL>http://www.orbolt.com/asset/SideFX::toonsimple</helpURL>
    <script scriptType="python"><![CDATA[import shelfutils
shelfutils.installOrboltAsset(kwargs, "SideFX::toonsimple", "http://www.orbolt.com/asset/SideFX::toonsimple")]]></script>
  </tool>

  <toolshelf name="gui2one" label="gui2one">
    <memberTool name="null_OUT"/>
    <memberTool name="dof_null"/>
    <memberTool name="dof_null_V2"/>
    <memberTool name="extract_planes"/>
    <memberTool name="CHOP_clean"/>
    <memberTool name="find reference"/>
    <memberTool name="HtoAE_V3"/>
    <memberTool name="obj_export"/>
    <memberTool name="freeze_curve_edit"/>
    <memberTool name="shader_preview"/>
    <memberTool name="place_obj"/>
    <memberTool name="copy_textures"/>
    <memberTool name="find_materials"/>
    <memberTool name="edges_to_curve"/>
    <memberTool name="bake_keyframes"/>
    <memberTool name="Cop_detect_passes"/>
    <memberTool name="import_AE3D_cam"/>
    <memberTool name="read_raw_file"/>
    <memberTool name="write_raw_file"/>
    <memberTool name="write_raw_file_V2"/>
    <memberTool name="octane_ROP_preview"/>
  </toolshelf>

  <tool name="null_OUT" label="null_OUT" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import sys

if(hou.selectedNodes().__len__() > 0):

    sel = hou.selectedNodes()[0]
    #print sel.outputs()
else:
    hou.ui.displayMessage("Select a node")
    # if selection is empty exit the tool
    sys.exit()
    

#print sel.children()   

nullNode = sel.parent().createNode("null")
nullNode.setName("OUT", True)
nullNode.setColor(hou.Color((1.0,0.0,0.0)))



for conn in sel.outputConnections():
    index = conn.inputIndex()
    outputNode = conn.outputItem()
    outputNode.setInput(index,nullNode)
    #print outputNode.name
  
nullNode.insertInput(0,sel)    

nullNode.moveToGoodPosition()

#nullNode.setDisplayFlag(1)
#nullNode.setRenderFlag(1)
#nullNode.setTemplateFlag(1)]]></script>
  </tool>

  <tool name="dof_null" label="dof_null" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[if hou.selectedNodes().__len__() > 0 : 
    c = hou.selectedNodes()[0]
    if c.type().name() == "cam" :
        root = c.parent()
        nullNode = root.createNode("null")
        nullNode.setName(c.name() + "_dof_null")
        nullNode.setPosition((c.position()[0], c.position()[1]-0.6))
        nullNode.parm("dcolorr").set(0.9)
        nullNode.parm("dcolorg").set(0.9)
        nullNode.parm("dcolorb").set(0.0)
        
        nullNode.parm("controltype").set(4)
        
        #################
        chopnet = root.createNode("chopnet")
        chopnet.setName(c.name()+"_chopnet")
        chopnet.setPosition((c.position()[0], c.position()[1]-1.1))
        nullObjNode = chopnet.createNode("object")
        nullObjNode.setName("dof_null_position")
        nullObjNode.parm("targetpath").set(nullNode.path())
        
        camObjNode = chopnet.createNode("object")
        camObjNode.setName("cam_position")
        camObjNode.parm("targetpath").set(c.path())        
        
        exp = 'distance('
        exp += 'chop("'+ camObjNode.path()+'/tx"),'
        exp += 'chop("'+ camObjNode.path()+'/ty"),'
        exp += 'chop("'+ camObjNode.path()+'/tz"),'        
        exp += 'chop("'+ nullObjNode.path()+'/tx"),'
        exp += 'chop("'+ nullObjNode.path()+'/ty"),'
        exp += 'chop("'+ nullObjNode.path()+'/tz"))'
        c.parm("focus").setExpression(exp)
        #print nullNode
    else :
        hou.ui.displayMessage("select a camera node")        
else :
    hou.ui.displayMessage("select a camera")
]]></script>
  </tool>

  <tool name="tool_1" label="New Tool" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import sys
sys.path.append("F:/HOUDINI_CONFIG/python")

import load_captures

load_captures.main()]]></script>
  </tool>

  <tool name="extract_planes" label="extract_planes" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[s = hou.selectedNodes()[0]
root = s.parent()

def findLights():
    lightPlanes = []
    print "Find Lights Function ----"
    for i in range(nPlanes):
        plane = s.planes()[i]
    
        ### if it's an "light" plane
        if plane.find("obj_") != -1:
            lightPlanes.append(plane)
            
    print len(lightPlanes), "Light Planes"
    
    nameArray = []
    
    for lightPlane in lightPlanes:
        lightName = lightPlane.split("_")[1]
        if not lightName in nameArray:
            nameArray.append(lightName)    

    return nameArray
            
            
            
myPlanes = ()
nPlanes = len(s.planes())
print nPlanes


lights = findLights()
colors = []
colors.append(hou.Color((255,0,0)))
colors.append(hou.Color((0,255,0)))
colors.append(hou.Color((0,0,255)))
colors.append(hou.Color((255,255,0)))

inc = 0
for light in lights:
    nodes = []
    for plane in s.planes():
        if plane.find(light) != -1 and plane.find("coat") == -1  and plane.find("reflect") == -1:
            extract = root.createNode("gui2one_COP_extract_channel")
            nodes.append(extract)
            extract.setInput(0,s)
            extract.setColor(colors[inc % 4])
            extract.parm("plane_name").set(plane)
            extract.setName(light +"__"+ plane.split("_")[2] + "__" +plane.split("_")[3])
            
    inc += 1
    
    
    for i in range(len(nodes)-1):
        addNode = root.createNode("add")
        
        if i == 0:
            addNode.setInput(0,nodes[i])
            addNode.setInput(1,nodes[i+1])
            oldAdd = addNode
        else:
            addNode.setInput(0, oldAdd    )
            addNode.setInput(1,nodes[i+1])
            oldAdd = addNode

inc = 0
for light in lights:
    nodes = []
    for plane in s.planes():
        if plane.find(light) != -1 :
            if plane.find("coat") != -1 or plane.find("reflect") != -1:
                extract = root.createNode("gui2one_COP_extract_channel")
                nodes.append(extract)
                extract.setInput(0,s)
                extract.setColor(colors[inc % 4])
                extract.parm("plane_name").set(plane)
                extract.setName(light +"__"+ plane.split("_")[2] + "__" +plane.split("_")[3])
            
    inc += 1
    
    
    for i in range(len(nodes)-1):
        addNode = root.createNode("add")
        
        if i == 0:
            addNode.setInput(0,nodes[i])
            addNode.setInput(1,nodes[i+1])
            oldAdd = addNode
        else:
            addNode.setInput(0, oldAdd    )
            addNode.setInput(1,nodes[i+1])
            oldAdd = addNode            
       ]]></script>
  </tool>

  <tool name="CHOP_clean" label="CHOP_clean" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[nodes = hou.selectedNodes()

inc = 0

for node in nodes :
    parm = node.parm("export")
    
    if parm.eval() != "":
        parm.set("")        
        inc += 1

print(str(inc) +" Chop node(s) Export prefix parm  cleaned")        
   
    ]]></script>
  </tool>

  <tool name="find reference" label="find reference" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import sys


inc = 0
paramsCounter = 0
nuggetsFound = []

r = hou.ui.readInput("node name to search :")
#r = (0,"OUT_oriented_tree_wires")
searchTarget = r[1]


if searchTarget != '' :
    rDomain = hou.ui.selectNode()

    print rDomain
    try :
        test = hou.node(rDomain).allSubChildren()
    except:
        print "problem"
        #sys.exit(0)
        
    for nd in hou.node(rDomain).allSubChildren() :
        for parm in nd.parms():
            paramsCounter += 1
            try:
                strParam = str(nd.evalParm(parm.path()))
                #print strParam
            except:
                #print "problem !!!!"
                strParam = ""
            if strParam.find(searchTarget)!= -1 :
                nuggetsFound.append(nd)
        inc+= 1
        
print ("%s nodes, %s paramters, %s nugget found" % (inc,paramsCounter,len(nuggetsFound)))
for nd in nuggetsFound :
    print (nd.path())

    

]]></script>
  </tool>

  <toolshelf name="CYCLES_utils" label="CYCLES_utils">
    <memberTool name="obj_export"/>
    <memberTool name="scene_export"/>
    <memberTool name="add_parms"/>
  </toolshelf>

  <tool name="scene_export" label="scene_export" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import math
import sys

sys.path.append('F:/HOUDINI_CONFIG/python/cycles_export')
import cycles_export as cy
reload(cy)

fileName = hou.ui.selectFile('name for exported file')

selection = hou.selectedNodes()

sceneString = ''
camNodes = []
lightNodes = []
objDict = {} 

for obj in selection :
    if obj.type().name() == 'cam':
        camNodes.append(obj)
    
        if len(camNodes) > 1 : 
            hou.ui.displayMessage("more than 1 camera is selected.\n Select only one camera.")
            sys.exit(0)

    elif obj.type().name() == 'hlight::2.0' :
        print 'this is a light !!!!!'
        lightNodes.append(obj)
        
        
    elif obj.type().name() == 'geo':
        objDict[obj] = obj.name()
    elif obj.type().name() == 'subnet':
        for child in obj.children():
            if child.type().name() == 'geo':   
                objDict[child] = obj.name()+"__"+child.name()             
                
sceneString = '<cycles>\n'
sceneString += '<camera width="640" height="360" />\n'   

for cam in camNodes:
    sceneString += cy.writeTransformsStart(cam)
    sceneString += cy.writeCamera(cam)
    sceneString += cy.writeTransformsEnd()    

    
    
sceneString += cy.writeBackgroundShader()

sceneString += cy.writeDefaultShader()

for light in lightNodes:
    sceneString += cy.writeLight(light)


for item in objDict:
    sceneString += cy.writeShader(item, objDict[item])
    sceneString += cy.writeTransformsStart(item)
    sceneString += cy.writeObject(objDict[item])
    sceneString += cy.writeTransformsEnd()   
    
sceneString += '</cycles>'
#print sceneString

f = open(fileName,"w")
f.write(sceneString)
f.close()



]]></script>
  </tool>

  <tool name="add_parms" label="add_parms" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[selection = hou.selectedNodes()



objNodes = []
for obj in selection :
    
    if obj.type().name() == 'geo':
        objNodes.append(obj)
        
    elif obj.type().name() == 'subnet':
        for child in obj.children():
            if child.type().name() == 'geo': 
                objNodes.append(child)     
                
                
for obj in objNodes:
    try:   
        group = obj.parmTemplateGroup()        
        foldToDelete = group.findFolder("Cycles")     
        print foldToDelete
        group.remove(foldToDelete)
        obj.setParmTemplateGroup(group)
    except:
        print 'no folder to remove'
    
    
    group = obj.parmTemplateGroup()
    
    folder = hou.FolderParmTemplate("cycles", "Cycles")
    
    menuTemplate = hou.MenuParmTemplate('bsdf1','BSDF 1',("diffuse","glossy"), default_value=0)
    folder.addParmTemplate(menuTemplate)        
    
    folder.addParmTemplate(hou.FloatParmTemplate("color1", "Color1",
                                                    3,
                                                    naming_scheme=hou.parmNamingScheme.RGBA,
                                                    look=hou.parmLook.ColorSquare,
                                                    default_value=(1.0,1.0,1.0)
                                                    ))
    floatTemplate = hou.FloatParmTemplate("roughness1", "Roughness1",1)
    floatTemplate.setDefaultValue((0.2,))
    folder.addParmTemplate( floatTemplate )
 
    
    menuTemplate = hou.MenuParmTemplate('bsdf2','BSDF 2',("diffuse","glossy"), default_value=1)
    folder.addParmTemplate(menuTemplate)        
    
    folder.addParmTemplate(hou.FloatParmTemplate("color2", "Color2",
                                                    3,
                                                    naming_scheme=hou.parmNamingScheme.RGBA,
                                                    look=hou.parmLook.ColorSquare,
                                                    default_value=(1.0,1.0,1.0)
                                                    ))
    floatTemplate = hou.FloatParmTemplate("roughness2", "Roughness2",1)
    floatTemplate.setDefaultValue((0.2,))
    folder.addParmTemplate( floatTemplate )    
    
    
    group.append(folder)
    obj.setParmTemplateGroup(group)]]></script>
  </tool>

  <tool name="obj_export" label="obj_export" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[folderPath = hou.ui.selectFile(title = "choose a folder")

selection = hou.selectedNodes()

objNodes = []
objDict = {}
for obj in selection :
    if obj.type().name() == 'geo':
        objNodes.append(obj)
        objDict[obj] = obj.name()
    elif obj.type().name() == 'subnet':
        for child in obj.children():
            if child.type().name() == 'geo': 
                objNodes.append(child)     
                objDict[child] = obj.name()+"__"+child.name()                
                
                
for item in objDict:
    obj = item
    print obj
#for obj in objNodes:
for item in objDict:
    obj = item
    objName = objDict[item]


    sopNode = obj.displayNode()
    geo = sopNode.geometry()  
    fileName = folderPath+objName+".xml"
    ptPosString = ''
    ptUvString = ''
    for pt in geo.points():
        pt_x = pt.position()[0]
        pt_y = pt.position()[1]
        pt_z = pt.position()[2]
        
        strToAdd = ('%s %s %s' %(pt_x*-1, pt_y, pt_z))
        ptPosString += strToAdd   
        ptPosString += "  "
        
#        pt_uvs = pt.attribValue("uv")
#        pt_uv_x = pt_uvs[0]
#        pt_uv_y = pt_uvs[1]
#        pt_uv_z = pt_uvs[2]
#        
#        ptUvString += ('%s %s %s' %(1-pt_uv_x, 1-pt_uv_y,0.0)) 
#        ptUvString += "  "    
        
        
    nvertsString = ''
    vertsString = ''
    
    for prim in geo.prims():
        nvertsString += str(len(prim.vertices()))+ " "
        for vert in prim.vertices():
            vertsString += str(vert.point().number())+" "
        vertsString += "  "
    
    strExport =  '<?xml version="1.0" ?>\n'
    strExport += '<cycles>\n'
    strExport += '<mesh P='
    strExport += ('"%s"' % ptPosString)
#    strExport += (' UV="%s"' % ptUvString)
    strExport += (' nverts="%s"' % nvertsString)
    
    strExport += (' verts="%s"' % vertsString)
    strExport += '/>\n'
    strExport += '</cycles>'
    

    f = open(("%s" % (fileName)),"w")
    f.write(strExport)
    f.close()
    
    print ("Export Succeeded for %s"% (objName))]]></script>
  </tool>

  <tool name="freeze_curve_edit" label="freeze_curve_edit" icon="PLASMA_App">
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <script scriptType="python"><![CDATA[import sys

selection = hou.selectedNodes()
if selection.__len__() == 0:
    hou.ui.displayMessage("select a edit sop node")
    sys.exit(0)

#print 'selected node : ',selection[0].name()
#print selection[0].inputs()[0].parm('coords').evalAsString()
geo = selection[0].geometry()

pointsString = ''

for point in geo.points():
    pointsString += '%s,%s,%s ' % (point.position()[0], point.position()[1], point.position()[2])
    
#print pointsString

recursiveInputs =  selection[0].inputAncestors()

for node in recursiveInputs:
    if node.type().name() == 'curve':
        curveNode = node
        break

if curveNode != None:
    #print 'curve Node is --> ', curveNode
    #newCurveNode = curveNode.parent().createNode('curve')
    curveNode.parm('coords').set(pointsString)
    
selection[0].destroy()]]></script>
  </tool>

  <tool name="shader_preview" label="shader preview" icon="PLASMA_App">
    <toolMenuContext name="network">
      <contextNetType>SHOP</contextNetType>
    </toolMenuContext>
    <script scriptType="python"><![CDATA[

selected = hou.selectedNodes()[0]

nodeType = selected.type().name()


typeOk = False
if nodeType.find("octane") != -1:
    typeOk = True
else:
    typeOk = False

    
print "typeOk : ", typeOk


### delete existing shaderBall_scene
try : 
    hou.node("/obj/gui2one_shaderball_scene1/").destroy()
except:
    pass
    
if typeOk:
    shaderScene = hou.node('/obj').createNode('gui2one_shaderball_scene')
    shaderScene.parm("shop_materialpath_shell").set(selected.path())
    
    shaderScene.parm("show_params_button").pressButton()
    
    shaderScene.parm("openIPR").pressButton()]]></script>
  </tool>

  <tool name="dof_null_V2" label="DOF V2" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[if hou.selectedNodes().__len__() == 1:
    selectedNode = hou.selectedNodes()[0]
    if selectedNode.type().name() == 'cam' :
        cam = selectedNode
        
        if cam.parm('dof_target') == None :
            group = cam.parmTemplateGroup()
            
            template = hou.StringParmTemplate('dof_target','dof target',1)
            template.setStringType(hou.stringParmType.NodeReference)
            
            trans= group.findFolder('Transform')
            group.insertBefore(trans,template)
            
            cam.setParmTemplateGroup(group)
        
            

        nullNode = cam.parent().createNode('null')
        nullNode.setName('dof_null_'  + cam.name())
        nullNode.setPosition( cam.position() - hou.Vector2(0,1))
        nullNode.parmTuple('dcolor').set((0.8,0,0))
        nullNode.parm("geoscale").set(0.3)
        nullNode.parm("displayicon").set(2)
        nullNode.parm("controltype").set(5)        
        nullNode.parm("shadedmode").set(1)            
        
        cam.parm('dof_target').set(nullNode.path())
        
        expr = 'cam = hou.node(".")'
        expr +='\ncamPos = cam.worldTransform().extractTranslates()'
        expr +='\ndofNull = hou.node(cam.parm("dof_target").evalAsString())'
        expr +='\nif dofNull:'
       
        expr +='\n\tdofNullPos = dofNull.worldTransform().extractTranslates()'        
        expr +='\n\treturn camPos.distanceTo(dofNullPos)'    
        expr += '\nelse:'
        expr +='\n\treturn 5.0'
        expr +='\n'
      
        
        cam.parm('focus').setExpression(expr,language=hou.exprLanguage.Python)

        
    else:
        hou.ui.displayMessage("select a camera node")
else:
    hou.ui.displayMessage("select only one camera node")]]></script>
  </tool>

  <tool name="place_obj" label="Place Obj" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[sel = hou.selectedNodes()[0]

for pane in hou.ui.curDesktop().panes():
    for tab in pane.tabs():
        if tab.type() == hou.paneTabType.SceneViewer :

            sceneViewer = tab
            break
    
newPos = sceneViewer.selectPositions()[0]

sel.parm("tx").set(newPos.x())
sel.parm("ty").set(newPos.y())
sel.parm("tz").set(newPos.z())]]></script>
  </tool>

  <tool name="copy_textures" label="Copy Textures" icon="hicon:/SVGIcons.index?BUTTONS_add_image.svg">
    <script scriptType="python"><![CDATA[import os
import shutil


chosenPath = hou.ui.selectFile("","select a folder to copy file into", file_type=hou.fileType.Directory)
hipPath = hou.expandString(chosenPath)
print os.path.abspath(hipPath)
print chosenPath

sel = hou.selectedNodes()

filesToCopy = []
linksDict = {}

for node in sel:
    for child in node.children():
    
        if child.type().name() == "octane::NT_TEX_IMAGE" or child.type().name() == "octane::NT_TEX_FLOATIMAGE" or child.type().name() == "octane::NT_TEX_ALPHAIMAGE":
    
            filePath = child.parm("A_FILENAME").eval()
            
            if not filePath in filesToCopy:
                filesToCopy.append(filePath)
            
    #print filesToCopy
    
    ### copy files to chosen directory
    for file in filesToCopy:
        shutil.copy2(file, hipPath)
        linksDict[ file ] = str(hipPath)+ str(os.path.basename(file))
        
        
    
    
    ### loop back through texture node in octane network to update image file paths
    for child in node.children():
    
        if child.type().name() == "octane::NT_TEX_IMAGE" or child.type().name() == "octane::NT_TEX_FLOATIMAGE" or child.type().name() == "octane::NT_TEX_ALPHAIMAGE":
            filePath = child.parm("A_FILENAME").eval()
            
            expandedHipString = hou.expandString("$HIP")
            newPath = linksDict[filePath].replace( expandedHipString, "$HIP")
            child.parm("A_FILENAME").set(newPath)
        
    
    
    
    
    
    ]]></script>
  </tool>

  <tool name="find_materials" label="Find Materials" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import soptoolutils
import toolutils
import os

sel = hou.selectedNodes()
shops = []
parmsDir = {}
for item in sel:
    #print "exploring : ", item.name()
    matParm = item.parm("shop_materialpath")
    objMat = matParm.eval()
    if objMat != "":
        shopPath = matParm.eval()
        #check if already a relative path
        if shopPath[:1] != "." :
            if shopPath != "" and not hou.node(shopPath) in shops:
                
                shops.append(hou.node(shopPath))
                parmsDir[ len(parmsDir)] = [matParm , shops.__len__()-1, item.path()]                        
                
            elif shopPath != "" :
                parmsDir[ len(parmsDir)] = [matParm , shops.__len__()-1, item.path()]
        
    children = item.glob("*")
    
    for child in children:
        if child.type().name() == "material":
            #print "\t-found Material sop : ", child.path()
         
            for i in range(child.parm("num_materials").eval()):
                shopPath = child.parm("shop_materialpath"+str(i+1)).eval()
                
                #check if already a relative path
                if shopPath[:1] != "." :                
                
                
                    if shopPath != "" and not hou.node(shopPath) in shops:
                        
                        shops.append(hou.node(shopPath))
                        parmsDir[ len(parmsDir)] = [child.parm("shop_materialpath"+str(i+1)) , shops.__len__()-1, child.path()]                        
                        
                    elif shopPath != "":
                        parmsDir[ len(parmsDir)] = [child.parm("shop_materialpath"+str(i+1)) , shops.__len__()-1, child.path()]
print shops 
#choices = []
#for item in shops:
#    choices.append(item.path())
#    
#choice = hou.ui.selectFromList(choices)

inc = 0
for entry in parmsDir:

    currentPath =  parmsDir[entry][0].eval()
    targetNode = hou.node(currentPath)
    
    currentNodePath = parmsDir[entry][2]
    
    #hou.cd(os.path.dirname(parmsDir[entry][2]))
    
    relativePath = hou.node(currentNodePath).relativePathTo(targetNode)

    print inc,currentNodePath,relativePath
    
    
    parmsDir[entry][0].set(relativePath)
    inc += 1
 
print parmsDir
                            
                
    ]]></script>
  </tool>

  <tool name="edges_to_curve" label="Edges To Curve" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import toolutils
import sys        
selection = toolutils.sceneViewer().selectGeometry()
selStr = selection.selectionStrings()


curveNodes = []
if selStr.__len__() == 0:
    print "no selection"
else:    
    #print "-----------------------"
    #print "selection :", selection
    nodes = selection.nodes()
    curSop = nodes[0]
    
    
    
    if selection.geometryType() == hou.geometryType.Edges:    
        segs = selStr[0].split(' ')   
        for seg in segs:
            #print "Seg :",seg
            curveNode = curSop.parent().createNode("curve")
            curveStr = ''
            pts = str(seg)[1:].split('-')
            pattern = ''
            for pt in pts:
                pattern += pt+' '
                curveStr += str(curSop.geometry().freeze().points()[int(pt)].position().x()) + ","
                curveStr += str(curSop.geometry().freeze().points()[int(pt)].position().y()) + ","
                curveStr += str(curSop.geometry().freeze().points()[int(pt)].position().z()) + " "

            
            curveNode.parm("coords").set(curveStr)
            curveNodes.append(curveNode)
            
        if len(curveNodes) > 1:
            mergeNode = curSop.parent().createNode('merge')
            for i,node in enumerate(curveNodes):
                mergeNode.setInput(i, node)
]]></script>
  </tool>

  <tool name="bake_keyframes" label="bake keyframes" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import sys
sel = hou.selectedNodes()
if len(sel) == 0:
    hou.ui.displayMessage("select a node with animted channel(s)")
    sys.exit()
  


def bakeKeyframes(node):
    animatedParms = [] 
    
    frameRange = range(int(hou.expandString('$RFSTART')), int(hou.expandString('$RFEND'))+1,1)
    
#    print frameRange

    obj = node
    print obj.name()
    
    bakeNull = hou.node("/obj/").createNode("null")
    print hou.node("baking_null_"+ obj.name())
    if hou.node("/obj/baking_null_"+ obj.name()) != None:
        print "hey"
        hou.node("/obj/baking_null_"+ obj.name()).destroy()
    bakeNull.setName("baking_null_"+ obj.name())
    bakeNull.moveToGoodPosition()    
    
    for parm in obj.parms():
        if len(parm.keyframes()) > 1:
            animatedParms.append(parm)
            
    print animatedParms
    
    
    keyframes_TX = []
    keyframes_TY = []    
    keyframes_TZ = []   
    
    keyframes_RX = []
    keyframes_RY = []    
    keyframes_RZ = []        
    
    for i in frameRange:
    
        time = float(i-1) / hou.fps()
       
        tr = obj.worldTransformAtTime( time ).extractTranslates()        
#        print i, " ----- " , tr.x()
        key = hou.Keyframe()
        key.setTime(time)
        key.setValue(tr.x())
        keyframes_TX.append(key)
        
        key = hou.Keyframe()
        key.setTime(time)
        key.setValue(tr.y())
        keyframes_TY.append(key)     
        
        key = hou.Keyframe()
        key.setTime(time)
        key.setValue(tr.z())
        keyframes_TZ.append(key)         
        
        
        rot = obj.worldTransformAtTime( time ).extractRotates()
        
        key = hou.Keyframe()
        key.setTime(time)
        key.setValue(rot.x())
        keyframes_RX.append(key)
        
        key = hou.Keyframe()
        key.setTime(time)
        key.setValue(rot.y())
        keyframes_RY.append(key)     
        
 
        key = hou.Keyframe()
        key.setTime(time)
        key.setValue(rot.z())
        keyframes_RZ.append(key)          

        
    # print keyframes_TX
    
    bakeNull.parm("tx").setKeyframes( keyframes_TX )
    bakeNull.parm("ty").setKeyframes( keyframes_TY )
    bakeNull.parm("tz").setKeyframes( keyframes_TZ )    
    
    bakeNull.parm("rx").setKeyframes( keyframes_RX )
    bakeNull.parm("ry").setKeyframes( keyframes_RY )
    bakeNull.parm("rz").setKeyframes( keyframes_RZ )        
    
    
    
    ## transfer keyframes to original object
    ## unparent before
    
    
    
    obj.parm("tx").deleteAllKeyframes()
    obj.parm("tx").setKeyframes(keyframes_TX)
    
    obj.parm("ty").deleteAllKeyframes()
    obj.parm("ty").setKeyframes(keyframes_TY)    
    
    obj.parm("tz").deleteAllKeyframes()
    obj.parm("tz").setKeyframes(keyframes_TZ)        
    
    obj.parm("rx").deleteAllKeyframes()
    obj.parm("rx").setKeyframes(keyframes_RX)  
    
    obj.parm("ry").deleteAllKeyframes()
    obj.parm("ry").setKeyframes(keyframes_RY)     
    
    obj.parm("rz").deleteAllKeyframes()
    obj.parm("rz").setKeyframes(keyframes_RZ)   
    
    obj.setInput(0,None)
    
bakeKeyframes(sel[0])]]></script>
  </tool>

  <tool name="Cop_detect_passes" label="COP detect passes" icon="hicon:/SVGIcons.index?BUTTONS_add_image.svg">
    <script scriptType="python"><![CDATA[import os
import re
import sys

file = hou.ui.selectFile("",pattern="*")

if file == "":
    sys.exit(0)
    
ext = os.path.splitext(file)[1]

print "extension :", ext

filePath = hou.expandString(file)

dirName = os.path.dirname(filePath)

allFiles = os.listdir(dirName)

imgFiles = []

listTitles = []

listNumFrames = []

for f in allFiles :
    if not os.path.isdir(os.path.join(dirName,f)):   
        
        if os.path.splitext(f)[1] == ext :
            imgFiles.append(f)
            regex = re.compile('\d+', re.IGNORECASE)
            
            startId = -1
            digits = ""
            for match in regex.finditer(f):
                if match.start() > startId :
                    startId = match.start()
                    digits = match.group(0)
                # print "%s: %s" % (match.start(), f)  
                
            # print "startId :",startId,"digits :", digits, "file :",f
            # mo = re.findall('\d+', f)
            strippedStr = f.replace(digits,"$F4")
            
            if not strippedStr in listTitles:
            
                listTitles.append( strippedStr )
                

                


imgNode = hou.node("/img/").createNode("img")
print dirName
copnetName = os.path.basename(filePath)
print "copnetName : ", copnetName
imgNode.setName(copnetName,  unique_name = True)
imgNode.moveToGoodPosition()


choices = hou.ui.selectFromList(listTitles)
for choice in choices:
    # print "choice :",choice
    fileNode = imgNode.createNode("file")
    fileNode.setName( os.path.basename( os.path.join(dirName, hou.expandString(listTitles[choice]))), unique_name = True)
    
    fileName = os.path.join(dirName, listTitles[choice])
    fileNode.parm("filename1").set(fileName.replace("\\","/"))
    
    # print listTitles[choice]
    
    
    
    
    
    
    
    
    
    
    
    ]]></script>
  </tool>

  <tool name="import_AE3D_cam" label="import AE3D camera" icon="hicon:/SVGIcons.index?CHOP_voicesplit.svg">
    <script scriptType="python"><![CDATA[cam = hou.node("/obj/").createNode("cam")

msFile = hou.ui.selectFile("Select ms file", pattern="*.ms")

f = open(msFile,"r")


data = f.readlines()

f.close()

framesArray = []
positions = []
rotations = []
for line in data :
    

    targetString = "at time"
    if targetString in line:
        frameNum = int( line[len(targetString)+1 : ].split(" ")[0])
        
        hou.setFrame( frameNum )
        if not frameNum in framesArray :
            framesArray.append(frameNum)
            rotation = []
            #print "\nFrame :", frameNum, "\n -----------------------------"
            
        if "x_rotation" in line:
            val = float(line.split(" = ")[1].strip("\n"))
            rotation.append(val)
            #print "rotation X : ", val
            
        elif "y_rotation" in line:
            val = float(line.split(" = ")[1].strip("\n"))
            rotation.append(val)
            #print "rotation Y : ", val
            
        elif "z_rotation" in line:
            val = float(line.split(" = ")[1].strip("\n"))
            rotation.append(val)
            rotations.append(rotation)
            #print "rotation Z : ", val
            
        elif ".pos" in line:
            posArray = line.split(" = ")[1].strip("\n").strip("[").strip("]").split(",")
            
            for i,item in enumerate(posArray):
                posArray[i] = float(item)
            position = posArray    
            positions.append(position)

#print rotations

# # after grabbing data, we create keyframes    
TX = []
TY = []
TZ = []

RX = []
RY = []
RZ = []
for i, frameNum in enumerate(framesArray):

    key = hou.Keyframe()
    key.setFrame( frameNum )
    key.setValue(positions[i][0])
    TX.append(key)
    
    key = hou.Keyframe()
    key.setFrame( frameNum )
    key.setValue(positions[i][1])
    TY.append(key)
    
    key = hou.Keyframe()
    key.setFrame( frameNum )
    key.setValue(positions[i][2])
    TZ.append(key)    
    
    key = hou.Keyframe()
    key.setFrame( frameNum )
    key.setValue(rotations[i][0])
    RX.append(key)   
    
    key = hou.Keyframe()
    key.setFrame( frameNum )
    key.setValue(rotations[i][1])
    RY.append(key)     
    
    key = hou.Keyframe()
    key.setFrame( frameNum )
    key.setValue(rotations[i][2])
    RZ.append(key)     
    
    
cam.parm("tx").setKeyframes( TX )    
cam.parm("ty").setKeyframes( TY )    
cam.parm("tz").setKeyframes( TZ )    

cam.parm("rx").setKeyframes( RX )    
cam.parm("ry").setKeyframes( RZ )    
cam.parm("rz").setKeyframes( RY )    
#print TX    
    
    
    
    
    
    
    
    
    
]]></script>
  </tool>

  <tool name="read_raw_file" label="read raw file" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import struct
import math
file = hou.ui.selectFile("","select Raw Height file",pattern="*.raw")
# print file

bytesArray = []


with open(file, "rb") as f:
    while True:
        chunk = f.read(2)
        if chunk:
            bytesArray.append((struct.unpack(">h",chunk))[0])
        else:
            break

            
print math.sqrt(len(bytesArray))
# example:
#for b in bytesArray:
#    height = 
#    if  height != 0 :
#        print height


]]></script>
  </tool>

  <tool name="write_raw_file" label="write raw file" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import struct 
import math
import os

def writeRawFile(filePath, height_field, numTiles=1):

    print "write file:", filePath
    data = ""
    for v in height_field.allVoxels():
        val =  hou.hmath.fit(v, minHeight, maxHeight,0.0,1.0)
        val = int(math.ceil( val * (((2**16)-1) - (2**15))))
        data += (struct.pack("@h",val))
        
    
    
    
    
    f = open(filePath, "wb")
    f.write(data)
    f.close()

def findPrim(baseSop, primName):
    prims = baseSop.geometry().prims()
    
    for i,prim in enumerate(prims):
        if prim.attribValue("name") == primName:
            #print "found height prim at prim #", i
            return prim
    
    return -1
    
    
choices = ("no tiles","2 by2", "3 by 3", "4 by 4")


tileChoice = hou.ui.selectFromList(choices,default_choices=(0,), exclusive=False)[0]



baseHeightField = hou.selectedNodes()[0]

heightPrim = findPrim(baseHeightField, 'height')
print "heightPrim :", heightPrim

flowPrim = findPrim(baseHeightField, 'flow')
print "flowPrim :", flowPrim

tileNode = baseHeightField.parent().createNode("heightfield_tilesplit")
tileNode.setInput(0,baseHeightField)
tileNode.setDisplayFlag(True)
tileNode.setTemplateFlag(True)
tileNode.setRenderFlag(True)
tileNode.moveToGoodPosition()
    


heightField = baseHeightField.geometry().prims()[0]

minHeight = heightField.volumeMin()
maxHeight = heightField.volumeMax()

print "minHeight :", minHeight
print "maxHeight :", maxHeight

if tileChoice == 0:
    filePath = hou.ui.selectFile("","select a file",pattern="*.raw")
    writeRawFile(filePath, heightField)
elif tileChoice != 0:    
    filePath = hou.ui.selectFile("","select a file",pattern="*.raw")
    tileNode.parm("tilecountx").set( tileChoice+1)
    tileNode.parm("tilecounty").set( tileChoice+1)    
    tileNode.parm("voxelpad").set(1)    
    for i in range(0, (tileChoice+1)**2):
        print "tile number ",i+1
        
        tileNode.parm("tilenum").set(i)
        heightField = tileNode.geometry().prims()[0]
        
        baseName, ext  = os.path.splitext(filePath)
        print baseName
        writeRawFile(baseName+ str(i)+ ext, heightField)
    

]]></script>
  </tool>

  <tool name="write_raw_file_V2" label="write raw file V2" icon="hicon:/SVGIcons.index?SOP_heightfield_file.svg">
    <script scriptType="python"><![CDATA[import struct 
import math
import os

def writeRawFile(filePath, height_field, minVal, maxVal):

    print "write file:", filePath
    data = ""
    for v in height_field.allVoxels():
        val =  hou.hmath.fit(v, minHeight, maxHeight,0.0,1.0)
        val = int(math.ceil( val * (((2**16)-1) - (2**15))))
        data += (struct.pack("@h",val))
        
    f = open(filePath, "wb")
    f.write(data)
    f.close()

def findPrim(baseSop, primName):
    prims = baseSop.geometry().prims()
    
    for i,prim in enumerate(prims):
        if prim.attribValue("name") == primName:
            #print "found height prim at prim #", i
            return prim
    
    return -1
    

def exportPrim( height_field_prim, num_tiles = 1):
    if height_field_prim == -1:
        print "prim not found"
        return -1
    print "exporting :",height_field_prim
    heightField = height_field_prim
    
    minVal = heightField.volumeMin()
    maxVal = heightField.volumeMax()
    
    print "minHeight :", minHeight
    print "maxHeight :", maxHeight
    
    if tileChoice == 0:
        filePath = hou.ui.selectFile("","select a file",pattern="*.raw")
        writeRawFile(filePath, heightField, minVal, maxVal)
    elif tileChoice != 0:    
        filePath = hou.ui.selectFile("","select a file",pattern="*.raw")
        tileNode.parm("tilecountx").set( tileChoice+1)
        tileNode.parm("tilecounty").set( tileChoice+1)    
        tileNode.parm("voxelpad").set(1)    
        for i in range(0, (tileChoice+1)**2):
            print "tile number ",i+1
            
            tileNode.parm("tilenum").set(i)
            heightField = tileNode.geometry().prims()[0]
            
            baseName, ext  = os.path.splitext(filePath)
            print baseName
            writeRawFile(baseName+ str(i)+ ext, heightField,  minVal, maxVal)
    
    
choices = ("no tiles","2 by2", "3 by 3", "4 by 4")


tileChoice = hou.ui.selectFromList(choices,default_choices=(0,), exclusive=False)[0]



baseHeightField = hou.selectedNodes()[0]





#print "flowPrim :", flowPrim

tileNode = baseHeightField.parent().createNode("heightfield_tilesplit")
tileNode.setInput(0,baseHeightField)
tileNode.setDisplayFlag(True)
tileNode.setTemplateFlag(True)
tileNode.setRenderFlag(True)
tileNode.moveToGoodPosition()

exportPrim(findPrim(baseHeightField, 'height'))
    



]]></script>
  </tool>

  <tool name="octane_ROP_preview" label="Octane Rop Preview" icon="hicon:/SVGIcons.index?BUTTONS_capture.svg">
    <toolMenuContext name="network">
      <contextNetType>ROP</contextNetType>
    </toolMenuContext>
    <script scriptType="python"><![CDATA[sel = hou.selectedNodes()
if len(sel) != 0:
    copiedNodes = hou.copyNodesTo((sel[0],), sel[0].parent())
    
    previewRop = copiedNodes[0]
    previewRop.setName(sel[0].name()+"_preview")
    previewRop.moveToGoodPosition()
    previewRop.setColor( hou.Color((255,0,0)))
    
    
    
    previewRop.parm("HO_overrideCameraRes").set(1)
    previewRop.parm("HO_overrideResScale").set(2)
    
    
    mainTake = hou.takes.rootTake()
    preview = mainTake.addChildTake("preview")
    
    
    hou.takes.setCurrentTake(preview)
    
    renderTarget = hou.node(sel[0].parm("HO_renderTarget").evalAsString())
    
    
    
    
    samplesParms = renderTarget.parmTuple("maxsamples")
    samplesParms2 = renderTarget.parmTuple("maxsamples2")
    samplesParms3 = renderTarget.parmTuple("maxsamples3")
    samplesParms4 = renderTarget.parmTuple("maxsamples4")
    #print samplesParms[0] 
    preview.addParmTuple(samplesParms)
    preview.addParmTuple(samplesParms2)
    preview.addParmTuple(samplesParms3)
    preview.addParmTuple(samplesParms4)
    
    
    samplesParms.set((500,))
    samplesParms2.set((500,))
    samplesParms3.set((500,))
    samplesParms4.set((500,))
    
    hou.takes.setCurrentTake(mainTake)
    
    previewRop.parm("take").set("preview")
]]></script>
  </tool>

  <tool name="HtoAE_V3" label="HtoAE V3" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import json
import math
import os

### functions
def isZoomTimeDependent(cam):
    parmList = [ 'focal', 'aperture']
    
    for parm in parmList:
        if cam.parm(parm).isTimeDependent():
            return True
            
    return False

def getCamZoomAtFrame(cam, frame=1):
    resx = cam.parm('resx').evalAtFrame(frame)
    resy = cam.parm('resy').evalAtFrame(frame)
    aspect = cam.parm('aspect').evalAtFrame(frame)
    aperture = cam.parm('aperture').evalAtFrame(frame)
    focal = cam.parm('focal').evalAtFrame(frame)
    fovx = 2 * math.atan((aperture/2)/focal) 
    zoom = ((resx/2)/math.tan(fovx/2)) 
    
    return zoom

def getTransformsAtFrame(obj, frame=1):
    hou.setFrame(frame)
    name = obj.name()
    objType = obj.type().name()
    wtm = obj.worldTransform()
    objt = wtm.extractTranslates("srt")
    tx = objt.__getitem__(0)
    ty = objt.__getitem__(1) * -1
    tz = objt.__getitem__(2) * -1
    objr = wtm.extractRotates("srt","zyx")
    rx = objr.__getitem__(0)
    ry = objr.__getitem__(1) * -1
    rz = objr.__getitem__(2) * -1
    
    return([tx,ty,tz], [rx,ry,rz])
        
        
### actual code 

sel = hou.selectedNodes()

tStart = int(hou.expandString('$RFSTART'))
tEnd = int(hou.expandString('$RFEND'))

nodes = {}

cam = None

for node in sel:
    if node.type().name() == 'cam':
        cam = node
        break

        
### file selection 
dirPath = hou.expandString('$HIP')
fileName = hou.ui.selectFile( start_directory = dirPath,
        default_value = "%s_export.h2ae" % (cam.name()),
        file_type = hou.fileType.Any,
        collapse_sequences = False,
        multiple_select = False,
        image_chooser   = False)
        
print fileName

data = {}
compInfos = {}
compInfos["name"] = cam.name()
compInfos["resx"] = cam.parm('resx').eval()
compInfos["resy"] = cam.parm('resy').eval()    
compInfos["fps"] = hou.fps()
compInfos["fStart"] = hou.expandString('$RFSTART')   
compInfos["fEnd"] = hou.expandString('$RFEND')

data["compInfos"] = compInfos

for node in sel:

    
    infos = {}
    if node.type().name() == 'cam' :
    
        camInfos = {}
        if not isZoomTimeDependent(node):
            camInfos["zoom"] = [getCamZoomAtFrame(node)]
            infos["camInfos"] = camInfos
            
        else:
            zoom = []
            for i in range(tStart, tEnd+1):
                zoom.append(getCamZoomAtFrame(node,i))
            camInfos["zoom"] = zoom
            infos["camInfos"] = camInfos
        
   
        
    positions = []
    rotations = []    
    
    if node.isTimeDependent() :
        for i in range(tStart, tEnd+1):
            pos, rot = getTransformsAtFrame(node,i)
            positions.append(pos)
            rotations.append(rot)
    else:
        pos, rot = getTransformsAtFrame(node)
        positions.append(pos)
        rotations.append(rot)        
        
    infos["positions"] = positions 
    infos["rotations"] = rotations
    nodes[node.name()] = infos

data["layers"] = nodes
    

    
    
jsonData = json.dumps(data, sort_keys=True, indent=4, separators=(',', ': '))
# jsonData = json.dumps(nodes)

with open(fileName,'w') as f:
    #json.dump(data,f, sort_keys=True, indent=4, separators=(',', ': '))
    json.dump(data, f, sort_keys=True)

print 'just written a file at : ', fileName


]]></script>
  </tool>

  <toolshelf name="destruction" label="Destruction">
    <memberTool name="fracture_object"/>
  </toolshelf>

  <tool name="fracture_object" label="Fracture Object" icon="hicon:/SVGIcons.index?SOP_shatter.svg">
    <script scriptType="python"><![CDATA[import os

rootPath = hou.getenv('CUSTOM_PYTHON_TOOLS')
execfile(os.path.join(rootPath, './fracture_object.py'))]]></script>
  </tool>

  <tool name="dynamics_debris" label="Debris" icon="SHELF_debris">
    <helpURL>tool:debris</helpURL>
    <script scriptType="python"><![CDATA[import toolutils
import soptoolutils
#print kwargs

activepane = toolutils.activePane(kwargs)
if activepane.type() != hou.paneTabType.SceneViewer:
    raise hou.Error("This tool cannot run in the current pane")

scene_viewer = toolutils.sceneViewer()
nodetypename = "delete"

# Obtain a geometry selection
geo_types = (hou.geometryType.Primitives, )
selection = scene_viewer.selectGeometry(
                "Select the primitives from which to create debris and press Enter to complete",
                geometry_types = geo_types,
                allow_obj_sel = True)
# The following will raise an exception if nothing was selected.
if len(selection.nodes()) == 0:
    raise hou.Error("Nothing was selected.")

#
# Create Source
#
# Create a new SOP container with the merged geometry 
container = soptoolutils.createSopNodeContainer(scene_viewer, "debris_source")
merge_sop = selection.mergedNode(container, nodetypename, True, True)
# Turn back on the display flag for merged nodes
for sop in selection.nodes():
    sop.parent().setDisplayFlag(True)

merge_sop.moveToGoodPosition()

unpack_sop = container.createNode('unpack')
unpack_sop.parm('limit_iterations').set(False)
unpack_sop.setFirstInput(merge_sop)
unpack_sop.moveToGoodPosition()

attribute_sop = container.createNode('attribute', 'remove_attributes')
attribute_sop.parm('ptdel').set('*')
attribute_sop.parm('vtxdel').set('*')
attribute_sop.parm('primdel').set('* ^name')
attribute_sop.parm('dtldel').set('*')
attribute_sop.setFirstInput(unpack_sop)
attribute_sop.moveToGoodPosition()

trail_sop = container.createNode('trail', 'compute_velocity')
trail_sop.parm('result').set('velocity')
trail_sop.setFirstInput(attribute_sop)
trail_sop.moveToGoodPosition()

debrissource_sop = container.createNode('debrissource')
debrissource_sop.setFirstInput(trail_sop)
debrissource_sop.moveToGoodPosition()

null_sop = container.createNode('null', 'OUT')
null_sop.setFirstInput(debrissource_sop)
null_sop.moveToGoodPosition()
null_sop.setDisplayFlag(True)
null_sop.setRenderFlag(True)

container.setDisplayFlag(False)

#
# Create Simulation
#
dopnet = container.parent().createNode('dopnet', 'debris_sim')
dopnet.moveToGoodPosition()

popobject = dopnet.createNode('popobject')
popobject.parm('friction').set(0.8)
popobject.parm('dynamicfriction').set(0.25)
popobject.moveToGoodPosition()

popsource = dopnet.createNode('popsource')
popsource.parm('emittype').set('point')
popsource.parm('soppath').set(null_sop.path())
popsource.parm('inheritattrib').set('* ^Cd')
popsource.parm('inheritvel').set(0.56)
popsource.moveToGoodPosition()

popstream = dopnet.createNode('popstream')
popstream.setFirstInput(popsource)
popstream.moveToGoodPosition()

popreplicate = dopnet.createNode('popreplicate')
popreplicate.parm('constantrate').set(100)
popreplicate.parm('killorig').set(True)
popreplicate.parm('shape').set('point')
popreplicate.parm('donoise').set(True)
popreplicate.parm('initvel').set('add')
popreplicate.parm('varx').set(0.7)
popreplicate.parm('vary').set(0.7)
popreplicate.parm('varz').set(0.7)
popreplicate.setFirstInput(popstream)
popreplicate.moveToGoodPosition()

popinteract = dopnet.createNode('popinteract')
popinteract.parm('positionforce').set(-0.2)
popinteract.parm('falloffradius').set(0.44)
popinteract.setFirstInput(popreplicate)
popinteract.moveToGoodPosition()

popdrag = dopnet.createNode('popdrag')
popdrag.parm('airresist').set(0.01)
popdrag.setFirstInput(popinteract)
popdrag.moveToGoodPosition()

popforce = dopnet.createNode('popforce')
popforce.parm('forcey').set(-9.80665)
popforce.setFirstInput(popdrag)
popforce.moveToGoodPosition()

popsolver = dopnet.createNode('popsolver')
popsolver.setFirstInput(popobject)
popsolver.setNextInput(popforce)
popsolver.setNextInput(popsource)
popsolver.moveToGoodPosition()

popsolver.setDisplayFlag(True)
dopnet.setDisplayFlag(False)

#
# Create Simulation
#
debris = container.parent().createNode('geo', 'debris', False)
debris.moveToGoodPosition()

dopimport = debris.createNode('dopimport')
dopimport.parm('doppath').set(dopnet.path())
dopimport.parm('importstyle').set('fetch')
dopimport.moveToGoodPosition()

# Change our viewer to the dop network
scene_viewer.setPwd(popsolver)
popsolver.setCurrent(True, True)
toolutils.homeToSelectionNetworkEditorsFor(popsolver)
scene_viewer.enterCurrentNodeState()]]></script>
  </tool>

  <shelfSetEdit name="shelf_set_1" fileLocation="C:/PROGRA~1/SIDEEF~1/HOUDIN~1.633/houdini/toolbar\ShelfDefinitions.shelf">
    <addMemberToolshelf name="octane" inPosition="16"/>
    <addMemberToolshelf name="gui2one" inPosition="17"/>
    <addMemberToolshelf name="destruction" inPosition="18"/>
  </shelfSetEdit>
</shelfDocument>
