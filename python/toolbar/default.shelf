<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <tool name="SideFX::toonsimple" orbolt="True" label="Toon Simple" icon="SideFX__toonsimple-icon.png">
    <helpText><![CDATA[Install or download the Toon Simple Orbolt digital asset.]]></helpText>
    <helpURL>http://www.orbolt.com/asset/SideFX::toonsimple</helpURL>
    <script scriptType="python"><![CDATA[import shelfutils
shelfutils.installOrboltAsset(kwargs, "SideFX::toonsimple", "http://www.orbolt.com/asset/SideFX::toonsimple")]]></script>
  </tool>

  <toolshelf name="gui2one" label="gui2one">
    <memberTool name="null_OUT"/>
    <memberTool name="dof_null"/>
    <memberTool name="dof_null_V2"/>
    <memberTool name="extract_planes"/>
    <memberTool name="CHOP_clean"/>
    <memberTool name="find reference"/>
    <memberTool name="HtoAE_V3"/>
    <memberTool name="obj_export"/>
    <memberTool name="freeze_curve_edit"/>
    <memberTool name="shader_preview"/>
    <memberTool name="place_obj"/>
    <memberTool name="copy_textures"/>
    <memberTool name="find_materials"/>
    <memberTool name="edges_to_curve"/>
    <memberTool name="bake_keyframes"/>
    <memberTool name="Cop_detect_passes"/>
    <memberTool name="import_AE3D_cam"/>
    <memberTool name="read_raw_file"/>
    <memberTool name="write_raw_file"/>
    <memberTool name="write_raw_file_V2"/>
    <memberTool name="octane_ROP_preview"/>
    <memberTool name="find_opened_definition"/>
    <memberTool name="pop render view"/>
    <memberTool name="add_ogl_params"/>
    <memberTool name="change_uv_display"/>
    <memberTool name="loadAECamFile"/>
    <memberTool name="cam_angle_to_F"/>
    <memberTool name="read_AE_data"/>
    <memberTool name="install_HIP_hdas"/>
    <memberTool name="list_parm_templates"/>
    <memberTool name="add_instance_point"/>
    <memberTool name="find_opened_HDAs"/>
    <memberTool name="ffmpeg_render"/>
    <memberTool name="osl_reload_script"/>
    <memberTool name="HipLoader"/>
    <memberTool name="check_duplicate_inputs"/>
  </toolshelf>

  <tool name="null_OUT" label="null_OUT" icon="PLASMA_App">
    <toolMenuContext name="viewer">
      <contextOpType>*</contextOpType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="cop_viewer">
      <contextNetType>COP2</contextNetType>
    </toolMenuContext>
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
      <contextNetType>CHOP</contextNetType>
      <contextNetType>SHOP</contextNetType>
      <contextNetType>COP2</contextNetType>
      <contextNetType>VOP</contextNetType>
      <contextNetType>VOPNET</contextNetType>
      <contextNetType>DOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>gui2one_scripts</toolSubmenu>
    <script scriptType="python"><![CDATA[import sys

if(hou.selectedNodes().__len__() > 0):

    sel = hou.selectedNodes()[0]

else:
    hou.ui.displayMessage("Select a node")
    # if selection is empty exit the tool
    sys.exit()
    

 

nullNode = sel.parent().createNode("null")
nullNode.setName("OUT", True)
nullNode.setColor(hou.Color((1.0,0.0,0.0)))



for conn in sel.outputConnections():
    index = conn.inputIndex()
    outputNode = conn.outputItem()
    outputNode.setInput(index,nullNode)

  
nullNode.insertInput(0,sel)    

nullNode.moveToGoodPosition()

]]></script>
  </tool>

  <tool name="dof_null" label="dof_null" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[if hou.selectedNodes().__len__() > 0 : 
    c = hou.selectedNodes()[0]
    if c.type().name() == "cam" :
        root = c.parent()
        nullNode = root.createNode("null")
        nullNode.setName(c.name() + "_dof_null")
        nullNode.setPosition((c.position()[0], c.position()[1]-0.6))
        nullNode.parm("dcolorr").set(0.9)
        nullNode.parm("dcolorg").set(0.9)
        nullNode.parm("dcolorb").set(0.0)
        
        nullNode.parm("controltype").set(4)
        
        #################
        chopnet = root.createNode("chopnet")
        chopnet.setName(c.name()+"_chopnet")
        chopnet.setPosition((c.position()[0], c.position()[1]-1.1))
        nullObjNode = chopnet.createNode("object")
        nullObjNode.setName("dof_null_position")
        nullObjNode.parm("targetpath").set(nullNode.path())
        
        camObjNode = chopnet.createNode("object")
        camObjNode.setName("cam_position")
        camObjNode.parm("targetpath").set(c.path())        
        
        exp = 'distance('
        exp += 'chop("'+ camObjNode.path()+'/tx"),'
        exp += 'chop("'+ camObjNode.path()+'/ty"),'
        exp += 'chop("'+ camObjNode.path()+'/tz"),'        
        exp += 'chop("'+ nullObjNode.path()+'/tx"),'
        exp += 'chop("'+ nullObjNode.path()+'/ty"),'
        exp += 'chop("'+ nullObjNode.path()+'/tz"))'
        c.parm("focus").setExpression(exp)
        #print nullNode
    else :
        hou.ui.displayMessage("select a camera node")        
else :
    hou.ui.displayMessage("select a camera")
]]></script>
  </tool>

  <tool name="tool_1" label="New Tool" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import sys
sys.path.append("F:/HOUDINI_CONFIG/python")

import load_captures

load_captures.main()]]></script>
  </tool>

  <tool name="extract_planes" label="extract_planes" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[s = hou.selectedNodes()[0]
root = s.parent()

def findLights():
    lightPlanes = []
    print "Find Lights Function ----"
    for i in range(nPlanes):
        plane = s.planes()[i]
    
        ### if it's an "light" plane
        if plane.find("obj_") != -1:
            lightPlanes.append(plane)
            
    print len(lightPlanes), "Light Planes"
    
    nameArray = []
    
    for lightPlane in lightPlanes:
        lightName = lightPlane.split("_")[1]
        if not lightName in nameArray:
            nameArray.append(lightName)    

    return nameArray
            
            
            
myPlanes = ()
nPlanes = len(s.planes())
print nPlanes


lights = findLights()
colors = []
colors.append(hou.Color((255,0,0)))
colors.append(hou.Color((0,255,0)))
colors.append(hou.Color((0,0,255)))
colors.append(hou.Color((255,255,0)))

inc = 0
for light in lights:
    nodes = []
    for plane in s.planes():
        if plane.find(light) != -1 and plane.find("coat") == -1  and plane.find("reflect") == -1:
            extract = root.createNode("gui2one_COP_extract_channel")
            nodes.append(extract)
            extract.setInput(0,s)
            extract.setColor(colors[inc % 4])
            extract.parm("plane_name").set(plane)
            extract.setName(light +"__"+ plane.split("_")[2] + "__" +plane.split("_")[3])
            
    inc += 1
    
    
    for i in range(len(nodes)-1):
        addNode = root.createNode("add")
        
        if i == 0:
            addNode.setInput(0,nodes[i])
            addNode.setInput(1,nodes[i+1])
            oldAdd = addNode
        else:
            addNode.setInput(0, oldAdd    )
            addNode.setInput(1,nodes[i+1])
            oldAdd = addNode

inc = 0
for light in lights:
    nodes = []
    for plane in s.planes():
        if plane.find(light) != -1 :
            if plane.find("coat") != -1 or plane.find("reflect") != -1:
                extract = root.createNode("gui2one_COP_extract_channel")
                nodes.append(extract)
                extract.setInput(0,s)
                extract.setColor(colors[inc % 4])
                extract.parm("plane_name").set(plane)
                extract.setName(light +"__"+ plane.split("_")[2] + "__" +plane.split("_")[3])
            
    inc += 1
    
    
    for i in range(len(nodes)-1):
        addNode = root.createNode("add")
        
        if i == 0:
            addNode.setInput(0,nodes[i])
            addNode.setInput(1,nodes[i+1])
            oldAdd = addNode
        else:
            addNode.setInput(0, oldAdd    )
            addNode.setInput(1,nodes[i+1])
            oldAdd = addNode            
       ]]></script>
  </tool>

  <tool name="CHOP_clean" label="CHOP_clean" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[nodes = hou.selectedNodes()

inc = 0

for node in nodes :
    parm = node.parm("export")
    
    if parm.eval() != "":
        parm.set("")        
        inc += 1

print(str(inc) +" Chop node(s) Export prefix parm  cleaned")        
   
    ]]></script>
  </tool>

  <tool name="find reference" label="find reference" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import sys


inc = 0
paramsCounter = 0
nuggetsFound = []

r = hou.ui.readInput("node name to search :")
#r = (0,"OUT_oriented_tree_wires")
searchTarget = r[1]


if searchTarget != '' :
    rDomain = hou.ui.selectNode()

    print rDomain
    try :
        test = hou.node(rDomain).allSubChildren()
    except:
        print "problem"
        #sys.exit(0)
        
    for nd in hou.node(rDomain).allSubChildren() :
        for parm in nd.parms():
            paramsCounter += 1
            try:
                strParam = str(nd.evalParm(parm.path()))
                #print strParam
            except:
                #print "problem !!!!"
                strParam = ""
            if strParam.find(searchTarget)!= -1 :
                nuggetsFound.append(nd)
        inc+= 1
        
print ("%s nodes, %s paramters, %s nugget found" % (inc,paramsCounter,len(nuggetsFound)))
for nd in nuggetsFound :
    print (nd.path())

    

]]></script>
  </tool>

  <toolshelf name="CYCLES_utils" label="CYCLES_utils">
    <memberTool name="obj_export"/>
    <memberTool name="scene_export"/>
    <memberTool name="add_parms"/>
  </toolshelf>

  <tool name="scene_export" label="scene_export" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import math
import sys

sys.path.append('F:/HOUDINI_CONFIG/python/cycles_export')
import cycles_export as cy
reload(cy)

fileName = hou.ui.selectFile('name for exported file')

selection = hou.selectedNodes()

sceneString = ''
camNodes = []
lightNodes = []
objDict = {} 

for obj in selection :
    if obj.type().name() == 'cam':
        camNodes.append(obj)
    
        if len(camNodes) > 1 : 
            hou.ui.displayMessage("more than 1 camera is selected.\n Select only one camera.")
            sys.exit(0)

    elif obj.type().name() == 'hlight::2.0' :
        print 'this is a light !!!!!'
        lightNodes.append(obj)
        
        
    elif obj.type().name() == 'geo':
        objDict[obj] = obj.name()
    elif obj.type().name() == 'subnet':
        for child in obj.children():
            if child.type().name() == 'geo':   
                objDict[child] = obj.name()+"__"+child.name()             
                
sceneString = '<cycles>\n'
sceneString += '<camera width="640" height="360" />\n'   

for cam in camNodes:
    sceneString += cy.writeTransformsStart(cam)
    sceneString += cy.writeCamera(cam)
    sceneString += cy.writeTransformsEnd()    

    
    
sceneString += cy.writeBackgroundShader()

sceneString += cy.writeDefaultShader()

for light in lightNodes:
    sceneString += cy.writeLight(light)


for item in objDict:
    sceneString += cy.writeShader(item, objDict[item])
    sceneString += cy.writeTransformsStart(item)
    sceneString += cy.writeObject(objDict[item])
    sceneString += cy.writeTransformsEnd()   
    
sceneString += '</cycles>'
#print sceneString

f = open(fileName,"w")
f.write(sceneString)
f.close()



]]></script>
  </tool>

  <tool name="add_parms" label="add_parms" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[selection = hou.selectedNodes()



objNodes = []
for obj in selection :
    
    if obj.type().name() == 'geo':
        objNodes.append(obj)
        
    elif obj.type().name() == 'subnet':
        for child in obj.children():
            if child.type().name() == 'geo': 
                objNodes.append(child)     
                
                
for obj in objNodes:
    try:   
        group = obj.parmTemplateGroup()        
        foldToDelete = group.findFolder("Cycles")     
        print foldToDelete
        group.remove(foldToDelete)
        obj.setParmTemplateGroup(group)
    except:
        print 'no folder to remove'
    
    
    group = obj.parmTemplateGroup()
    
    folder = hou.FolderParmTemplate("cycles", "Cycles")
    
    menuTemplate = hou.MenuParmTemplate('bsdf1','BSDF 1',("diffuse","glossy"), default_value=0)
    folder.addParmTemplate(menuTemplate)        
    
    folder.addParmTemplate(hou.FloatParmTemplate("color1", "Color1",
                                                    3,
                                                    naming_scheme=hou.parmNamingScheme.RGBA,
                                                    look=hou.parmLook.ColorSquare,
                                                    default_value=(1.0,1.0,1.0)
                                                    ))
    floatTemplate = hou.FloatParmTemplate("roughness1", "Roughness1",1)
    floatTemplate.setDefaultValue((0.2,))
    folder.addParmTemplate( floatTemplate )
 
    
    menuTemplate = hou.MenuParmTemplate('bsdf2','BSDF 2',("diffuse","glossy"), default_value=1)
    folder.addParmTemplate(menuTemplate)        
    
    folder.addParmTemplate(hou.FloatParmTemplate("color2", "Color2",
                                                    3,
                                                    naming_scheme=hou.parmNamingScheme.RGBA,
                                                    look=hou.parmLook.ColorSquare,
                                                    default_value=(1.0,1.0,1.0)
                                                    ))
    floatTemplate = hou.FloatParmTemplate("roughness2", "Roughness2",1)
    floatTemplate.setDefaultValue((0.2,))
    folder.addParmTemplate( floatTemplate )    
    
    
    group.append(folder)
    obj.setParmTemplateGroup(group)]]></script>
  </tool>

  <tool name="obj_export" label="obj_export" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[folderPath = hou.ui.selectFile(title = "choose a folder")

selection = hou.selectedNodes()

objNodes = []
objDict = {}
for obj in selection :
    if obj.type().name() == 'geo':
        objNodes.append(obj)
        objDict[obj] = obj.name()
    elif obj.type().name() == 'subnet':
        for child in obj.children():
            if child.type().name() == 'geo': 
                objNodes.append(child)     
                objDict[child] = obj.name()+"__"+child.name()                
                
                
for item in objDict:
    obj = item
    print obj
#for obj in objNodes:
for item in objDict:
    obj = item
    objName = objDict[item]


    sopNode = obj.displayNode()
    geo = sopNode.geometry()  
    fileName = folderPath+objName+".xml"
    ptPosString = ''
    ptUvString = ''
    for pt in geo.points():
        pt_x = pt.position()[0]
        pt_y = pt.position()[1]
        pt_z = pt.position()[2]
        
        strToAdd = ('%s %s %s' %(pt_x*-1, pt_y, pt_z))
        ptPosString += strToAdd   
        ptPosString += "  "
        
#        pt_uvs = pt.attribValue("uv")
#        pt_uv_x = pt_uvs[0]
#        pt_uv_y = pt_uvs[1]
#        pt_uv_z = pt_uvs[2]
#        
#        ptUvString += ('%s %s %s' %(1-pt_uv_x, 1-pt_uv_y,0.0)) 
#        ptUvString += "  "    
        
        
    nvertsString = ''
    vertsString = ''
    
    for prim in geo.prims():
        nvertsString += str(len(prim.vertices()))+ " "
        for vert in prim.vertices():
            vertsString += str(vert.point().number())+" "
        vertsString += "  "
    
    strExport =  '<?xml version="1.0" ?>\n'
    strExport += '<cycles>\n'
    strExport += '<mesh P='
    strExport += ('"%s"' % ptPosString)
#    strExport += (' UV="%s"' % ptUvString)
    strExport += (' nverts="%s"' % nvertsString)
    
    strExport += (' verts="%s"' % vertsString)
    strExport += '/>\n'
    strExport += '</cycles>'
    

    f = open(("%s" % (fileName)),"w")
    f.write(strExport)
    f.close()
    
    print ("Export Succeeded for %s"% (objName))]]></script>
  </tool>

  <tool name="freeze_curve_edit" label="freeze_curve_edit" icon="PLASMA_App">
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <script scriptType="python"><![CDATA[import sys

selection = hou.selectedNodes()
if selection.__len__() == 0:
    hou.ui.displayMessage("select a edit sop node")
    sys.exit(0)

#print 'selected node : ',selection[0].name()
#print selection[0].inputs()[0].parm('coords').evalAsString()
geo = selection[0].geometry()

pointsString = ''

for point in geo.points():
    pointsString += '%s,%s,%s ' % (point.position()[0], point.position()[1], point.position()[2])
    
#print pointsString

recursiveInputs =  selection[0].inputAncestors()

for node in recursiveInputs:
    if node.type().name() == 'curve':
        curveNode = node
        break

if curveNode != None:
    #print 'curve Node is --> ', curveNode
    #newCurveNode = curveNode.parent().createNode('curve')
    curveNode.parm('coords').set(pointsString)
    
selection[0].destroy()]]></script>
  </tool>

  <tool name="shader_preview" label="shader preview" icon="PLASMA_App">
    <toolMenuContext name="network">
      <contextOpType>mat</contextOpType>
      <contextNetType>SHOP</contextNetType>
      <contextNetType>VOPNET</contextNetType>
    </toolMenuContext>
    <toolSubmenu>gui2one_scripts</toolSubmenu>
    <script scriptType="python"><![CDATA[

selected = hou.selectedNodes()[0]

nodeType = selected.type().name()


typeOk = False
if nodeType.find("octane") != -1:
    typeOk = True
else:
    typeOk = False

    
print "typeOk : ", typeOk


### delete existing shaderBall_scene
try : 
    hou.node("/obj/gui2one_shaderball_scene1/").destroy()
except:
    pass
    
if typeOk:
    shaderScene = hou.node('/obj').createNode('gui2one_shaderball_scene')
    shaderScene.parm("shop_materialpath_shell").set(selected.path())
    
    shaderScene.parm("show_params_button").pressButton()
    
    shaderScene.parm("openIPR").pressButton()]]></script>
  </tool>

  <tool name="dof_null_V2" label="DOF V2" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[if hou.selectedNodes().__len__() == 1:
    selectedNode = hou.selectedNodes()[0]
    if selectedNode.type().name() == 'cam' :
        cam = selectedNode
        
        if cam.parm('dof_target') == None :
            group = cam.parmTemplateGroup()
            
            template = hou.StringParmTemplate('dof_target','dof target',1)
            template.setStringType(hou.stringParmType.NodeReference)
            
            trans= group.findFolder('Transform')
            group.insertBefore(trans,template)
            
            cam.setParmTemplateGroup(group)
        
            

        nullNode = cam.parent().createNode('null')
        nullNode.setName('dof_null_'  + cam.name())
        nullNode.setPosition( cam.position() - hou.Vector2(0,1))
        nullNode.parmTuple('dcolor').set((0.8,0,0))
        nullNode.parm("geoscale").set(0.3)
        nullNode.parm("displayicon").set(2)
        nullNode.parm("controltype").set(5)        
        nullNode.parm("shadedmode").set(1)            
        
        cam.parm('dof_target').set(nullNode.path())
        
        expr = 'cam = hou.node(".")'
        expr +='\ncamPos = cam.worldTransform().extractTranslates()'
        expr +='\ndofNull = hou.node(cam.parm("dof_target").evalAsString())'
        expr +='\nif dofNull:'
       
        expr +='\n\tdofNullPos = dofNull.worldTransform().extractTranslates()'        
        expr +='\n\treturn camPos.distanceTo(dofNullPos)'    
        expr += '\nelse:'
        expr +='\n\treturn 5.0'
        expr +='\n'
      
        
        cam.parm('focus').setExpression(expr,language=hou.exprLanguage.Python)

        
    else:
        hou.ui.displayMessage("select a camera node")
else:
    hou.ui.displayMessage("select only one camera node")]]></script>
  </tool>

  <tool name="place_obj" label="Place Obj" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[sel = hou.selectedNodes()[0]

for pane in hou.ui.curDesktop().panes():
    for tab in pane.tabs():
        if tab.type() == hou.paneTabType.SceneViewer :

            sceneViewer = tab
            break
    
newPos = sceneViewer.selectPositions()[0]

sel.parm("tx").set(newPos.x())
sel.parm("ty").set(newPos.y())
sel.parm("tz").set(newPos.z())]]></script>
  </tool>

  <tool name="copy_textures" label="Copy Textures" icon="hicon:/SVGIcons.index?BUTTONS_add_image.svg">
    <script scriptType="python"><![CDATA[import os
import shutil


chosenPath = hou.ui.selectFile("","select a folder to copy file into", file_type=hou.fileType.Directory)
hipPath = hou.expandString(chosenPath)
print os.path.abspath(hipPath)
print chosenPath

sel = hou.selectedNodes()

filesToCopy = []
linksDict = {}

for node in sel:
    for child in node.children():
    
        if child.type().name() == "octane::NT_TEX_IMAGE" or child.type().name() == "octane::NT_TEX_FLOATIMAGE" or child.type().name() == "octane::NT_TEX_ALPHAIMAGE":
    
            filePath = child.parm("A_FILENAME").eval()
            
            if not filePath in filesToCopy:
                filesToCopy.append(filePath)
            
    #print filesToCopy
    
    ### copy files to chosen directory
    for file in filesToCopy:
        shutil.copy2(file, hipPath)
        linksDict[ file ] = str(hipPath)+ str(os.path.basename(file))
        
        
    
    
    ### loop back through texture node in octane network to update image file paths
    for child in node.children():
    
        if child.type().name() == "octane::NT_TEX_IMAGE" or child.type().name() == "octane::NT_TEX_FLOATIMAGE" or child.type().name() == "octane::NT_TEX_ALPHAIMAGE":
            filePath = child.parm("A_FILENAME").eval()
            
            expandedHipString = hou.expandString("$HIP")
            newPath = linksDict[filePath].replace( expandedHipString, "$HIP")
            child.parm("A_FILENAME").set(newPath)
        
    
    
    
    
    
    ]]></script>
  </tool>

  <tool name="find_materials" label="Find Materials" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import soptoolutils
import toolutils
import os

sel = hou.selectedNodes()
shops = []
parmsDir = {}
for item in sel:
    #print "exploring : ", item.name()
    matParm = item.parm("shop_materialpath")
    objMat = matParm.eval()
    if objMat != "":
        shopPath = matParm.eval()
        #check if already a relative path
        if shopPath[:1] != "." :
            if shopPath != "" and not hou.node(shopPath) in shops:
                
                shops.append(hou.node(shopPath))
                parmsDir[ len(parmsDir)] = [matParm , shops.__len__()-1, item.path()]                        
                
            elif shopPath != "" :
                parmsDir[ len(parmsDir)] = [matParm , shops.__len__()-1, item.path()]
        
    children = item.glob("*")
    
    for child in children:
        if child.type().name() == "material":
            #print "\t-found Material sop : ", child.path()
         
            for i in range(child.parm("num_materials").eval()):
                shopPath = child.parm("shop_materialpath"+str(i+1)).eval()
                
                #check if already a relative path
                if shopPath[:1] != "." :                
                
                
                    if shopPath != "" and not hou.node(shopPath) in shops:
                        
                        shops.append(hou.node(shopPath))
                        parmsDir[ len(parmsDir)] = [child.parm("shop_materialpath"+str(i+1)) , shops.__len__()-1, child.path()]                        
                        
                    elif shopPath != "":
                        parmsDir[ len(parmsDir)] = [child.parm("shop_materialpath"+str(i+1)) , shops.__len__()-1, child.path()]
print shops 
#choices = []
#for item in shops:
#    choices.append(item.path())
#    
#choice = hou.ui.selectFromList(choices)

inc = 0
for entry in parmsDir:

    currentPath =  parmsDir[entry][0].eval()
    targetNode = hou.node(currentPath)
    
    currentNodePath = parmsDir[entry][2]
    
    #hou.cd(os.path.dirname(parmsDir[entry][2]))
    
    relativePath = hou.node(currentNodePath).relativePathTo(targetNode)

    print inc,currentNodePath,relativePath
    
    
    parmsDir[entry][0].set(relativePath)
    inc += 1
 
print parmsDir
                            
                
    ]]></script>
  </tool>

  <tool name="edges_to_curve" label="Edges To Curve" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import toolutils
import sys        
selection = toolutils.sceneViewer().selectGeometry()
selStr = selection.selectionStrings()


curveNodes = []
if selStr.__len__() == 0:
    print "no selection"
else:    
    #print "-----------------------"
    #print "selection :", selection
    nodes = selection.nodes()
    curSop = nodes[0]
    
    
    
    if selection.geometryType() == hou.geometryType.Edges:    
        segs = selStr[0].split(' ')   
        for seg in segs:
            #print "Seg :",seg
            curveNode = curSop.parent().createNode("curve")
            curveStr = ''
            pts = str(seg)[1:].split('-')
            pattern = ''
            for pt in pts:
                pattern += pt+' '
                curveStr += str(curSop.geometry().freeze().points()[int(pt)].position().x()) + ","
                curveStr += str(curSop.geometry().freeze().points()[int(pt)].position().y()) + ","
                curveStr += str(curSop.geometry().freeze().points()[int(pt)].position().z()) + " "

            
            curveNode.parm("coords").set(curveStr)
            curveNodes.append(curveNode)
            
        if len(curveNodes) > 1:
            mergeNode = curSop.parent().createNode('merge')
            for i,node in enumerate(curveNodes):
                mergeNode.setInput(i, node)
]]></script>
  </tool>

  <tool name="bake_keyframes" label="bake keyframes" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import sys
sel = hou.selectedNodes()
if len(sel) == 0:
    hou.ui.displayMessage("select a node with animted channel(s)")
    sys.exit()
  


def bakeKeyframes(node):
    animatedParms = [] 
    
    frameRange = range(int(hou.expandString('$RFSTART')), int(hou.expandString('$RFEND'))+1,1)
    
#    print frameRange

    obj = node
    print obj.name()
    
    bakeNull = hou.node("/obj/").createNode("null")
    print hou.node("baking_null_"+ obj.name())
    if hou.node("/obj/baking_null_"+ obj.name()) != None:
        print "hey"
        hou.node("/obj/baking_null_"+ obj.name()).destroy()
    bakeNull.setName("baking_null_"+ obj.name())
    bakeNull.moveToGoodPosition()    
    
    for parm in obj.parms():
        if len(parm.keyframes()) > 1:
            animatedParms.append(parm)
            
    print animatedParms
    
    
    keyframes_TX = []
    keyframes_TY = []    
    keyframes_TZ = []   
    
    keyframes_RX = []
    keyframes_RY = []    
    keyframes_RZ = []        
    
    for i in frameRange:
    
        time = float(i-1) / hou.fps()
       
        tr = obj.worldTransformAtTime( time ).extractTranslates()        
#        print i, " ----- " , tr.x()
        key = hou.Keyframe()
        key.setTime(time)
        key.setValue(tr.x())
        keyframes_TX.append(key)
        
        key = hou.Keyframe()
        key.setTime(time)
        key.setValue(tr.y())
        keyframes_TY.append(key)     
        
        key = hou.Keyframe()
        key.setTime(time)
        key.setValue(tr.z())
        keyframes_TZ.append(key)         
        
        
        rot = obj.worldTransformAtTime( time ).extractRotates()
        
        key = hou.Keyframe()
        key.setTime(time)
        key.setValue(rot.x())
        keyframes_RX.append(key)
        
        key = hou.Keyframe()
        key.setTime(time)
        key.setValue(rot.y())
        keyframes_RY.append(key)     
        
 
        key = hou.Keyframe()
        key.setTime(time)
        key.setValue(rot.z())
        keyframes_RZ.append(key)          

        
    # print keyframes_TX
    
    bakeNull.parm("tx").setKeyframes( keyframes_TX )
    bakeNull.parm("ty").setKeyframes( keyframes_TY )
    bakeNull.parm("tz").setKeyframes( keyframes_TZ )    
    
    bakeNull.parm("rx").setKeyframes( keyframes_RX )
    bakeNull.parm("ry").setKeyframes( keyframes_RY )
    bakeNull.parm("rz").setKeyframes( keyframes_RZ )        
    
    
    
    ## transfer keyframes to original object
    ## unparent before
    
    
    
    obj.parm("tx").deleteAllKeyframes()
    obj.parm("tx").setKeyframes(keyframes_TX)
    
    obj.parm("ty").deleteAllKeyframes()
    obj.parm("ty").setKeyframes(keyframes_TY)    
    
    obj.parm("tz").deleteAllKeyframes()
    obj.parm("tz").setKeyframes(keyframes_TZ)        
    
    obj.parm("rx").deleteAllKeyframes()
    obj.parm("rx").setKeyframes(keyframes_RX)  
    
    obj.parm("ry").deleteAllKeyframes()
    obj.parm("ry").setKeyframes(keyframes_RY)     
    
    obj.parm("rz").deleteAllKeyframes()
    obj.parm("rz").setKeyframes(keyframes_RZ)   
    
    obj.setInput(0,None)
    
bakeKeyframes(sel[0])]]></script>
  </tool>

  <tool name="Cop_detect_passes" label="COP detect passes" icon="hicon:/SVGIcons.index?BUTTONS_add_image.svg">
    <toolMenuContext name="network">
      <contextOpType>/img</contextOpType>
      <contextNetType>COP2</contextNetType>
    </toolMenuContext>
    <script scriptType="python"><![CDATA[import os
import re
import sys

file = hou.ui.selectFile("",pattern="*")

if file == "":
    sys.exit(0)
    
ext = os.path.splitext(file)[1]

#print "extension :", ext

filePath = hou.expandString(file)

dirName = os.path.dirname(filePath)

allFiles = os.listdir(dirName)

imgFiles = []

listTitles = []

listNumFrames = []

for f in allFiles :
    if not os.path.isdir(os.path.join(dirName,f)):   
        
        if os.path.splitext(f)[1] == ext :
            imgFiles.append(f)
            regex = re.compile('\d+', re.IGNORECASE)
            
            startId = -1
            digits = ""
            for match in regex.finditer(f):
                if match.start() > startId :
                    startId = match.start()
                    digits = match.group(0)
                # print "%s: %s" % (match.start(), f)  
                
            # print "startId :",startId,"digits :", digits, "file :",f
            # mo = re.findall('\d+', f)
            strippedStr = f.replace(digits,"$F4")
            
            if not strippedStr in listTitles:
            
                listTitles.append( strippedStr )
                

                


imgNode = hou.node("/img/").createNode("img")
print dirName
copnetName = os.path.basename(filePath)
print "copnetName : ", copnetName
imgNode.setName(copnetName,  unique_name = True)
imgNode.moveToGoodPosition()


choices = hou.ui.selectFromList(listTitles)
if len(choices) == 0 :
    imgNode.destroy()
    sys.exit(0)
    
fileNodes = []
for choice in choices:
    # print "choice :",choice
    fileNode = imgNode.createNode("file")
    fileNode.setName( os.path.basename( os.path.join(dirName, hou.expandString(listTitles[choice]))), unique_name = True)
    
    fileName = os.path.join(dirName, listTitles[choice])
    fileNode.parm("filename1").set(fileName.replace("\\","/"))
    
    fileNodes.append(fileNode)
    # print listTitles[choice]

last = fileNodes[0]
for i in range(len(fileNodes)-1) :
#    print fileNodes[i]
    addNode = imgNode.createNode("add")
    addNode.setFirstInput(last)
    addNode.setInput(1,fileNodes[i+1])    
    
    last = addNode
    
    
    
    
    
    
    
    
    
    
    
    ]]></script>
  </tool>

  <tool name="import_AE3D_cam" label="import AE3D camera" icon="hicon:/SVGIcons.index?CHOP_voicesplit.svg">
    <script scriptType="python"><![CDATA[cam = hou.node("/obj/").createNode("cam")

msFile = hou.ui.selectFile("Select ms file", pattern="*.ms")

f = open(msFile,"r")


data = f.readlines()

f.close()

framesArray = []
positions = []
rotations = []
for line in data :
    

    targetString = "at time"
    if targetString in line:
        frameNum = int( line[len(targetString)+1 : ].split(" ")[0])
        
        hou.setFrame( frameNum )
        if not frameNum in framesArray :
            framesArray.append(frameNum)
            rotation = []
            #print "\nFrame :", frameNum, "\n -----------------------------"
            
        if "x_rotation" in line:
            val = float(line.split(" = ")[1].strip("\n"))
            rotation.append(val)
            #print "rotation X : ", val
            
        elif "y_rotation" in line:
            val = float(line.split(" = ")[1].strip("\n"))
            rotation.append(val)
            #print "rotation Y : ", val
            
        elif "z_rotation" in line:
            val = float(line.split(" = ")[1].strip("\n"))
            rotation.append(val)
            rotations.append(rotation)
            #print "rotation Z : ", val
            
        elif ".pos" in line:
            posArray = line.split(" = ")[1].strip("\n").strip("[").strip("]").split(",")
            
            for i,item in enumerate(posArray):
                posArray[i] = float(item)
            position = posArray    
            positions.append(position)

#print rotations

# # after grabbing data, we create keyframes    
TX = []
TY = []
TZ = []

RX = []
RY = []
RZ = []
for i, frameNum in enumerate(framesArray):

    key = hou.Keyframe()
    key.setFrame( frameNum )
    key.setValue(positions[i][0])
    TX.append(key)
    
    key = hou.Keyframe()
    key.setFrame( frameNum )
    key.setValue(positions[i][1])
    TY.append(key)
    
    key = hou.Keyframe()
    key.setFrame( frameNum )
    key.setValue(positions[i][2])
    TZ.append(key)    
    
    key = hou.Keyframe()
    key.setFrame( frameNum )
    key.setValue(rotations[i][0])
    RX.append(key)   
    
    key = hou.Keyframe()
    key.setFrame( frameNum )
    key.setValue(rotations[i][1])
    RY.append(key)     
    
    key = hou.Keyframe()
    key.setFrame( frameNum )
    key.setValue(rotations[i][2])
    RZ.append(key)     
    
    
cam.parm("tx").setKeyframes( TX )    
cam.parm("ty").setKeyframes( TY )    
cam.parm("tz").setKeyframes( TZ )    

cam.parm("rx").setKeyframes( RX )    
cam.parm("ry").setKeyframes( RZ )    
cam.parm("rz").setKeyframes( RY )    
#print TX    
    
    
    
    
    
    
    
    
    
]]></script>
  </tool>

  <tool name="read_raw_file" label="read raw file" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import struct
import math
file = hou.ui.selectFile("","select Raw Height file",pattern="*.raw")
# print file

bytesArray = []


with open(file, "rb") as f:
    while True:
        chunk = f.read(2)
        if chunk:
            bytesArray.append((struct.unpack(">h",chunk))[0])
        else:
            break

            
print math.sqrt(len(bytesArray))
# example:
#for b in bytesArray:
#    height = 
#    if  height != 0 :
#        print height


]]></script>
  </tool>

  <tool name="write_raw_file" label="write raw file" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import struct 
import math
import os

def writeRawFile(filePath, height_field, numTiles=1):

    print "write file:", filePath
    data = ""
    for v in height_field.allVoxels():
        val =  hou.hmath.fit(v, minHeight, maxHeight,0.0,1.0)
        val = int(math.ceil( val * (((2**16)-1) - (2**15))))
        data += (struct.pack("@h",val))
        
    
    
    
    
    f = open(filePath, "wb")
    f.write(data)
    f.close()

def findPrim(baseSop, primName):
    prims = baseSop.geometry().prims()
    
    for i,prim in enumerate(prims):
        if prim.attribValue("name") == primName:
            #print "found height prim at prim #", i
            return prim
    
    return -1
    
    
choices = ("no tiles","2 by2", "3 by 3", "4 by 4")


tileChoice = hou.ui.selectFromList(choices,default_choices=(0,), exclusive=False)[0]



baseHeightField = hou.selectedNodes()[0]

heightPrim = findPrim(baseHeightField, 'height')
print "heightPrim :", heightPrim

flowPrim = findPrim(baseHeightField, 'flow')
print "flowPrim :", flowPrim

tileNode = baseHeightField.parent().createNode("heightfield_tilesplit")
tileNode.setInput(0,baseHeightField)
tileNode.setDisplayFlag(True)
tileNode.setTemplateFlag(True)
tileNode.setRenderFlag(True)
tileNode.moveToGoodPosition()
    


heightField = baseHeightField.geometry().prims()[0]

minHeight = heightField.volumeMin()
maxHeight = heightField.volumeMax()

print "minHeight :", minHeight
print "maxHeight :", maxHeight

if tileChoice == 0:
    filePath = hou.ui.selectFile("","select a file",pattern="*.raw")
    writeRawFile(filePath, heightField)
elif tileChoice != 0:    
    filePath = hou.ui.selectFile("","select a file",pattern="*.raw")
    tileNode.parm("tilecountx").set( tileChoice+1)
    tileNode.parm("tilecounty").set( tileChoice+1)    
    tileNode.parm("voxelpad").set(1)    
    for i in range(0, (tileChoice+1)**2):
        print "tile number ",i+1
        
        tileNode.parm("tilenum").set(i)
        heightField = tileNode.geometry().prims()[0]
        
        baseName, ext  = os.path.splitext(filePath)
        print baseName
        writeRawFile(baseName+ str(i)+ ext, heightField)
    

]]></script>
  </tool>

  <tool name="write_raw_file_V2" label="write raw file V2" icon="hicon:/SVGIcons.index?SOP_heightfield_file.svg">
    <script scriptType="python"><![CDATA[import struct 
import math
import os

def writeRawFile(filePath, height_field, minVal, maxVal):

    print "write file:", filePath
    data = ""
    for v in height_field.allVoxels():
        val =  hou.hmath.fit(v, minHeight, maxHeight,0.0,1.0)
        val = int(math.ceil( val * (((2**16)-1) - (2**15))))
        data += (struct.pack("@h",val))
        
    f = open(filePath, "wb")
    f.write(data)
    f.close()

def findPrim(baseSop, primName):
    prims = baseSop.geometry().prims()
    
    for i,prim in enumerate(prims):
        if prim.attribValue("name") == primName:
            #print "found height prim at prim #", i
            return prim
    
    return -1
    

def exportPrim( height_field_prim, num_tiles = 1):
    if height_field_prim == -1:
        print "prim not found"
        return -1
    print "exporting :",height_field_prim
    heightField = height_field_prim
    
    minVal = heightField.volumeMin()
    maxVal = heightField.volumeMax()
    
    print "minHeight :", minHeight
    print "maxHeight :", maxHeight
    
    if tileChoice == 0:
        filePath = hou.ui.selectFile("","select a file",pattern="*.raw")
        writeRawFile(filePath, heightField, minVal, maxVal)
    elif tileChoice != 0:    
        filePath = hou.ui.selectFile("","select a file",pattern="*.raw")
        tileNode.parm("tilecountx").set( tileChoice+1)
        tileNode.parm("tilecounty").set( tileChoice+1)    
        tileNode.parm("voxelpad").set(1)    
        for i in range(0, (tileChoice+1)**2):
            print "tile number ",i+1
            
            tileNode.parm("tilenum").set(i)
            heightField = tileNode.geometry().prims()[0]
            
            baseName, ext  = os.path.splitext(filePath)
            print baseName
            writeRawFile(baseName+ str(i)+ ext, heightField,  minVal, maxVal)
    
    
choices = ("no tiles","2 by2", "3 by 3", "4 by 4")


tileChoice = hou.ui.selectFromList(choices,default_choices=(0,), exclusive=False)[0]



baseHeightField = hou.selectedNodes()[0]





#print "flowPrim :", flowPrim

tileNode = baseHeightField.parent().createNode("heightfield_tilesplit")
tileNode.setInput(0,baseHeightField)
tileNode.setDisplayFlag(True)
tileNode.setTemplateFlag(True)
tileNode.setRenderFlag(True)
tileNode.moveToGoodPosition()

exportPrim(findPrim(baseHeightField, 'height'))
    



]]></script>
  </tool>

  <tool name="octane_ROP_preview" label="Octane Rop Preview" icon="hicon:/SVGIcons.index?BUTTONS_capture.svg">
    <toolMenuContext name="network">
      <contextNetType>ROP</contextNetType>
    </toolMenuContext>
    <script scriptType="python"><![CDATA[sel = hou.selectedNodes()
if len(sel) != 0:
    copiedNodes = hou.copyNodesTo((sel[0],), sel[0].parent())
    
    previewRop = copiedNodes[0]
    previewRop.setName(sel[0].name()+"_preview")
    previewRop.moveToGoodPosition()
    previewRop.setColor( hou.Color((255,0,0)))
    
    
    
    previewRop.parm("HO_overrideCameraRes").set(1)
    previewRop.parm("HO_overrideResScale").set(2)
    
    
    mainTake = hou.takes.rootTake()
    preview = mainTake.addChildTake("preview")
    
    
    hou.takes.setCurrentTake(preview)
    
    renderTarget = hou.node(sel[0].parm("HO_renderTarget").evalAsString())
    
    
    
    
    samplesParms = renderTarget.parmTuple("maxsamples")
    samplesParms2 = renderTarget.parmTuple("maxsamples2")
    samplesParms3 = renderTarget.parmTuple("maxsamples3")
    samplesParms4 = renderTarget.parmTuple("maxsamples4")
    #print samplesParms[0] 
    preview.addParmTuple(samplesParms)
    preview.addParmTuple(samplesParms2)
    preview.addParmTuple(samplesParms3)
    preview.addParmTuple(samplesParms4)
    
    
    samplesParms.set((500,))
    samplesParms2.set((500,))
    samplesParms3.set((500,))
    samplesParms4.set((500,))
    
    hou.takes.setCurrentTake(mainTake)
    
    previewRop.parm("take").set("preview")
]]></script>
  </tool>

  <tool name="HtoAE_V3" label="HtoAE V3" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import json
import math
import os

### functions
def isZoomTimeDependent(cam):
    parmList = [ 'focal', 'aperture']
    
    for parm in parmList:
        if cam.parm(parm).isTimeDependent():
            return True
            
    return False

def getCamZoomAtFrame(cam, frame=1):
    resx = cam.parm('resx').evalAtFrame(frame)
    resy = cam.parm('resy').evalAtFrame(frame)
    aspect = cam.parm('aspect').evalAtFrame(frame)
    aperture = cam.parm('aperture').evalAtFrame(frame)
    focal = cam.parm('focal').evalAtFrame(frame)
    fovx = 2 * math.atan((aperture/2)/focal) 
    zoom = ((resx/2)/math.tan(fovx/2)) 
    
    return zoom

def getTransformsAtFrame(obj, frame=1):
    hou.setFrame(frame)
    name = obj.name()
    objType = obj.type().name()
    wtm = obj.worldTransform()
    objt = wtm.extractTranslates("srt")
    tx = objt.__getitem__(0)
    ty = objt.__getitem__(1) * -1
    tz = objt.__getitem__(2) * -1
    objr = wtm.extractRotates("srt","zyx")
    rx = objr.__getitem__(0)
    ry = objr.__getitem__(1) * -1
    rz = objr.__getitem__(2) * -1
    
    return([tx,ty,tz], [rx,ry,rz])
        
        
### actual code 

sel = hou.selectedNodes()

tStart = int(hou.expandString('$RFSTART'))
tEnd = int(hou.expandString('$RFEND'))

nodes = {}

cam = None

for node in sel:
    if node.type().name() == 'cam':
        cam = node
        break

        
### file selection 
dirPath = hou.expandString('$HIP')
fileName = hou.ui.selectFile( start_directory = dirPath,
        default_value = "%s_export.h2ae" % (cam.name()),
        file_type = hou.fileType.Any,
        collapse_sequences = False,
        multiple_select = False,
        image_chooser   = False)
        
print fileName

data = {}
compInfos = {}
compInfos["name"] = cam.name()
compInfos["resx"] = cam.parm('resx').eval()
compInfos["resy"] = cam.parm('resy').eval()    
compInfos["fps"] = hou.fps()
compInfos["fStart"] = hou.expandString('$RFSTART')   
compInfos["fEnd"] = hou.expandString('$RFEND')

data["compInfos"] = compInfos

for node in sel:

    
    infos = {}
    if node.type().name() == 'cam' :
    
        camInfos = {}
        if not isZoomTimeDependent(node):
            camInfos["zoom"] = [getCamZoomAtFrame(node)]
            infos["camInfos"] = camInfos
            
        else:
            zoom = []
            for i in range(tStart, tEnd+1):
                zoom.append(getCamZoomAtFrame(node,i))
            camInfos["zoom"] = zoom
            infos["camInfos"] = camInfos
        
   
        
    positions = []
    rotations = []    
    
    if node.isTimeDependent() :
        for i in range(tStart, tEnd+1):
            pos, rot = getTransformsAtFrame(node,i)
            positions.append(pos)
            rotations.append(rot)
    else:
        pos, rot = getTransformsAtFrame(node)
        positions.append(pos)
        rotations.append(rot)        
        
    infos["positions"] = positions 
    infos["rotations"] = rotations
    nodes[node.name()] = infos

data["layers"] = nodes
    

    
    
jsonData = json.dumps(data, sort_keys=True, indent=4, separators=(',', ': '))
# jsonData = json.dumps(nodes)

with open(fileName,'w') as f:
    #json.dump(data,f, sort_keys=True, indent=4, separators=(',', ': '))
    json.dump(data, f, sort_keys=True)

print 'just written a file at : ', fileName


]]></script>
  </tool>

  <toolshelf name="destruction" label="Destruction">
    <memberTool name="fracture_object"/>
    <memberTool name="debris_sim"/>
    <memberTool name="dust_sim"/>
    <memberTool name="small_chunks_sim"/>
    <memberTool name="reset_debris_sims"/>
  </toolshelf>

  <tool name="fracture_object" label="Fracture Object" icon="hicon:/SVGIcons.index?SOP_shatter.svg">
    <script scriptType="python"><![CDATA[import os
rootPath = hou.getenv('CUSTOM_PYTHON_TOOLS')
execfile(os.path.join(rootPath, './fracture_object.py'))]]></script>
  </tool>

  <tool name="dynamics_debris" label="Debris" icon="SHELF_debris">
    <helpURL>tool:debris</helpURL>
    <script scriptType="python"><![CDATA[import toolutils
import soptoolutils
#print kwargs

activepane = toolutils.activePane(kwargs)
if activepane.type() != hou.paneTabType.SceneViewer:
    raise hou.Error("This tool cannot run in the current pane")

scene_viewer = toolutils.sceneViewer()
nodetypename = "delete"

# Obtain a geometry selection
geo_types = (hou.geometryType.Primitives, )
selection = scene_viewer.selectGeometry(
                "Select the primitives from which to create debris and press Enter to complete",
                geometry_types = geo_types,
                allow_obj_sel = True)
# The following will raise an exception if nothing was selected.
if len(selection.nodes()) == 0:
    raise hou.Error("Nothing was selected.")

#
# Create Source
#
# Create a new SOP container with the merged geometry 
container = soptoolutils.createSopNodeContainer(scene_viewer, "debris_source")
merge_sop = selection.mergedNode(container, nodetypename, True, True)
# Turn back on the display flag for merged nodes
for sop in selection.nodes():
    sop.parent().setDisplayFlag(True)

merge_sop.moveToGoodPosition()

unpack_sop = container.createNode('unpack')
unpack_sop.parm('limit_iterations').set(False)
unpack_sop.setFirstInput(merge_sop)
unpack_sop.moveToGoodPosition()

attribute_sop = container.createNode('attribute', 'remove_attributes')
attribute_sop.parm('ptdel').set('*')
attribute_sop.parm('vtxdel').set('*')
attribute_sop.parm('primdel').set('* ^name')
attribute_sop.parm('dtldel').set('*')
attribute_sop.setFirstInput(unpack_sop)
attribute_sop.moveToGoodPosition()

trail_sop = container.createNode('trail', 'compute_velocity')
trail_sop.parm('result').set('velocity')
trail_sop.setFirstInput(attribute_sop)
trail_sop.moveToGoodPosition()

debrissource_sop = container.createNode('debrissource')
debrissource_sop.setFirstInput(trail_sop)
debrissource_sop.moveToGoodPosition()

null_sop = container.createNode('null', 'OUT')
null_sop.setFirstInput(debrissource_sop)
null_sop.moveToGoodPosition()
null_sop.setDisplayFlag(True)
null_sop.setRenderFlag(True)

container.setDisplayFlag(False)

#
# Create Simulation
#
dopnet = container.parent().createNode('dopnet', 'debris_sim')
dopnet.moveToGoodPosition()

popobject = dopnet.createNode('popobject')
popobject.parm('friction').set(0.8)
popobject.parm('dynamicfriction').set(0.25)
popobject.moveToGoodPosition()

popsource = dopnet.createNode('popsource')
popsource.parm('emittype').set('point')
popsource.parm('soppath').set(null_sop.path())
popsource.parm('inheritattrib').set('* ^Cd')
popsource.parm('inheritvel').set(0.56)
popsource.moveToGoodPosition()

popstream = dopnet.createNode('popstream')
popstream.setFirstInput(popsource)
popstream.moveToGoodPosition()

popreplicate = dopnet.createNode('popreplicate')
popreplicate.parm('constantrate').set(100)
popreplicate.parm('killorig').set(True)
popreplicate.parm('shape').set('point')
popreplicate.parm('donoise').set(True)
popreplicate.parm('initvel').set('add')
popreplicate.parm('varx').set(0.7)
popreplicate.parm('vary').set(0.7)
popreplicate.parm('varz').set(0.7)
popreplicate.setFirstInput(popstream)
popreplicate.moveToGoodPosition()

popinteract = dopnet.createNode('popinteract')
popinteract.parm('positionforce').set(-0.2)
popinteract.parm('falloffradius').set(0.44)
popinteract.setFirstInput(popreplicate)
popinteract.moveToGoodPosition()

popdrag = dopnet.createNode('popdrag')
popdrag.parm('airresist').set(0.01)
popdrag.setFirstInput(popinteract)
popdrag.moveToGoodPosition()

popforce = dopnet.createNode('popforce')
popforce.parm('forcey').set(-9.80665)
popforce.setFirstInput(popdrag)
popforce.moveToGoodPosition()

popsolver = dopnet.createNode('popsolver')
popsolver.setFirstInput(popobject)
popsolver.setNextInput(popforce)
popsolver.setNextInput(popsource)
popsolver.moveToGoodPosition()

popsolver.setDisplayFlag(True)
dopnet.setDisplayFlag(False)

#
# Create Simulation
#
debris = container.parent().createNode('geo', 'debris', False)
debris.moveToGoodPosition()

dopimport = debris.createNode('dopimport')
dopimport.parm('doppath').set(dopnet.path())
dopimport.parm('importstyle').set('fetch')
dopimport.moveToGoodPosition()

# Change our viewer to the dop network
scene_viewer.setPwd(popsolver)
popsolver.setCurrent(True, True)
toolutils.homeToSelectionNetworkEditorsFor(popsolver)
scene_viewer.enterCurrentNodeState()]]></script>
  </tool>

  <tool name="debris_sim" label="Debris Sim" icon="SHELF_debris">
    <script scriptType="python"><![CDATA[import os

rootPath = hou.getenv('CUSTOM_PYTHON_TOOLS')
execfile(os.path.join(rootPath, './debris_sim.py'),{'hou' : hou }, {'kwargs': {'pane':None }} )
]]></script>
  </tool>

  <tool name="dust_sim" label="Dust Sim" icon="hicon:/SVGIcons.index?DOP_smokeobject.svg">
    <script scriptType="python"><![CDATA[import os

rootPath = hou.getenv('CUSTOM_PYTHON_TOOLS')
execfile(os.path.join(rootPath, './dust_sim.py'),{'hou' : hou }, {'kwargs': {'pane':None }} )
]]></script>
  </tool>

  <tool name="reset_debris_sims" label="Reset Debris Sims" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[allNodes = hou.node('/obj').allSubChildren()

for node in allNodes:
    if node.type().name() == 'debrissource':
        if node.parent().type().name() == 'gui2one_debris_source':
            print '------> ',node.parent().path()
            node.parent().parm('resimulate').pressButton()
        else:
            print '------> ',node.parent().path()
            node.parm('resimulate').pressButton()            
            ]]></script>
  </tool>

  <tool name="small_chunks_sim" label="Small Chunks Sim" icon="SHELF_debris">
    <script scriptType="python"><![CDATA[import os

rootPath = hou.getenv('CUSTOM_PYTHON_TOOLS')
execfile(os.path.join(rootPath, './small_chunks_sim.py'),{'hou' : hou }, {'kwargs': {'pane':None }} )
]]></script>
  </tool>

  <tool name="find_opened_definition" label="Find Opened Definition" icon="PLASMA_App">
    <toolMenuContext name="network">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
      <contextNetType>CHOP</contextNetType>
      <contextNetType>ROP</contextNetType>
      <contextNetType>SHOP</contextNetType>
      <contextNetType>COP2</contextNetType>
      <contextNetType>VOP</contextNetType>
      <contextNetType>VOPNET</contextNetType>
      <contextNetType>DOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>gui2one_scripts</toolSubmenu>
    <script scriptType="python"><![CDATA[selection = hou.selectedNodes()


if len(selection) == 0:
    hou.ui.displayMessage("select an asset of whitch type you want to find opened definitions ")
else : 
    assetTypeName = selection[0].type().name()
    foundNum = 0
    for node in hou.node('/').allSubChildren():
        if node.type().name() == assetTypeName:
            if node.isEditable() :
                print node.isEditable() ,'--->', node.path()
                foundNum += 1
    if foundNum == 0 :
        print "no opened definition found for asset type ",assetTypeName]]></script>
  </tool>

  <tool name="pop render view" label="Pop Render View" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[desk = hou.ui.curDesktop()

foundIPR = False

for pane in desk.panes():
    for tab in pane.tabs():
        if tab.type() == hou.paneTabType.IPRViewer:
            print "ipr viewer found"
            tab.setIsCurrentTab()
            foundIPR = True
            
for panel in hou.ui.floatingPanels():
    for tab in panel.paneTabs():
        if tab.type() == hou.paneTabType.IPRViewer:
            print "ipr viewer found 2"
            print tab.name()
            tab.setIsCurrentTab()
            foundIPR = True            
            
if not foundIPR:
    IPR = desk.createFloatingPanel(hou.paneTabType.IPRViewer)
    IPR.setName('mantra ipr')
            ]]></script>
  </tool>

  <tool name="add_ogl_params" label="Add OGL Params" icon="hicon:/SVGIcons.index?BUTTONS_list_add.svg">
    <toolMenuContext name="network">
      <contextNetType>SHOP</contextNetType>
      <contextNetType>VOP</contextNetType>
      <contextNetType>VOPNET</contextNetType>
    </toolMenuContext>
    <toolSubmenu>gui2one_scripts</toolSubmenu>
    <script scriptType="python"><![CDATA[
sel = hou.selectedNodes()

for node in sel:
    if node.type().name() == 'materialbuilder' or node.type().name() == 'octane_vopnet' :
        # print "ok"
        
        existingParms = node.parmTemplateGroup()
        # print existingParms
        group = hou.ParmTemplateGroup()
        folder = hou.FolderParmTemplate("ogl_parms","OGL")
            
        folder.addParmTemplate( hou.StringParmTemplate("ogl_tex1","texture 1",1, string_type=hou.stringParmType.FileReference))
        folder.addParmTemplate( hou.StringParmTemplate("ogl_texuvset1","uv set 1",1, string_type=hou.stringParmType.Regular))
        
        
        
        texWrapMenu = hou.MenuParmTemplate('ogl_tex_wrap1','Texture Wrap',menu_items=(["repeat","clamp","decal","mirror"]), menu_labels=(["Repeat","Streak","Decal","Mirror"]))
        folder.addParmTemplate(texWrapMenu)
        
        existingParms.append(folder)
        try:
            node.setParmTemplateGroup( existingParms )
        except hou.OperationFailed:
            # print "Params already present ?"
            pass
         
            
        ## now try and find a texture in the material network
        for child in node.children():
            if child.type().name() == 'collect':
                print "found"
                for input in child.inputs():
                    print input
                    if input.type().name() == 'output':
                        print "found output"
                        
        ]]></script>
  </tool>

  <tool name="change_uv_display" label="Change UV Display" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import toolutils

viewer = toolutils.sceneViewer()
vp = viewer.curViewport()
content = dir( vp )

list = ['uv','uv2','uv3','uv4','uv5','uv6','uv7','uv8','uv9','uv10']
choice = hou.ui.selectFromList(list, clear_on_cancel = True)
settings = vp.settings()

if len(choice) != 0:
    settings.setUVDisplayAttribute(list[choice[0]])
#for entry in content:
#    print entry]]></script>
  </tool>

  <tool name="loadAECamFile" label="Load AE Cam File" icon="hicon:/SVGIcons.index?OBJ_camera.svg">
    <script scriptType="python"><![CDATA[import math
import json


def calcCamF(angle, aperture):
    f =  ( aperture / 2.0) / math.tan( math.radians(angle/ 2.0) ) 
    return f


file = hou.expandString(hou.ui.selectFile(title="select a .cam file", pattern="*.cam"))


SCALE = 0.01;
print hou.expandString(file)
data = ""
with open(file,"r") as f:
    data = f.read()
    
jsonData = json.loads(data)
print len(jsonData)
for item in jsonData:
#    print item['type']
    if item['type'] == "camera":
        node = hou.node("/obj/").createNode("cam")
        node.setName(item['name'].replace(' ','_'), unique_name=True)
        node.parm("resx") .set(float(item["resX"]))
        node.parm("resy") .set(float(item["resY"]))
        
        aperture = float(item["aperture"])
        angle = float(item['angle'])
        node.parm("aperture").set(aperture)
        focal = calcCamF(angle,aperture)
        node.parm("focal").set(focal)        
        
    elif item['type'] == "AVLayer":
        node = hou.node("/obj/").createNode("null")
        node.setName(item['name'].replace(' ','_'), unique_name=True)
        
    for i,frame in enumerate(item['positions']):
        key = hou.Keyframe()
        key.setFrame(i)
        key.setValue(float(frame[0] * SCALE))       
        node.parm("tx").setKeyframe(key)
        
        key = hou.Keyframe()
        key.setFrame(i)
        key.setValue(float(-frame[1] * SCALE))       
        node.parm("ty").setKeyframe(key)        
        
        key = hou.Keyframe()
        key.setFrame(i)
        key.setValue(float(-frame[2] * SCALE))       
        node.parm("tz").setKeyframe(key)
        
    for i,frame in enumerate(item['orientations']):
        key = hou.Keyframe()
        key.setFrame(i)
        key.setValue(float(frame[0]))       
        node.parm("rx").setKeyframe(key)
        
        key = hou.Keyframe()
        key.setFrame(i)
        key.setValue(-float(frame[1]))       
        node.parm("ry").setKeyframe(key)        
        
        key = hou.Keyframe()
        key.setFrame(i)
        key.setValue(-float(frame[2]))       
        node.parm("rz").setKeyframe(key)    
        
        ]]></script>
  </tool>

  <tool name="cam_angle_to_F" label="Cam Angleto F" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import math

def calcCamF(angle, aperture):
    f =  ( aperture / 2.0) / math.tan( math.radians(angle/ 2.0) ) 
    return f
    
res = hou.ui.readMultiInput("enter camera parameters",("angle", "aperture"))

if len(res) > 0:
    params = res[1]
    angle = float(params[0])
    aperture = float(params[1])
    
    f = calcCamF( angle, aperture)
    print "focal length : ", f
    
    if len(hou.selectedNodes()) > 0:
        node = hou.selectedNodes()[0]
        if node.type().name() == 'cam':
            node.parm('focal').set(f)
            node.parm('aperture').set(aperture)
            
    else :
        print "focal length :", f
        print "aperture : ", aperture
        
    ]]></script>
  </tool>

  <tool name="read_AE_data" label="Read AE Data" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[file = hou.ui.selectFile("$HIP/",title = "choose .txt file", pattern="*.txt")
print file

with open(file,'rU') as f:
    for line in f:
        line_data = line.replace("\t","").replace("\n","").replace("\r","")
        if line_data != "":
            print line_data]]></script>
  </tool>

  <tool name="install_HIP_hdas" label="Install $HIP HDAs" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import os

full_path = os.path.join(hou.expandString('$HIP'),"otls")

inc = 0
success_num = 0
failed_num = 0
for item in os.listdir(full_path):
    is_file = os.path.isdir(os.path.join(full_path,item)) == False
    
    if is_file :
        try : 
            hou.hda.installFile(os.path.join(full_path, item))

            success_num += 1
        except :
            print 'oups. problem while installing hda definition:'
            print os.path.join(full_path, item)
            failed_num += 1

        inc += 1

if inc == 0:
    print "-------"
    print "no hda installed"
else :
    print "-------"
    print inc, "definition files found : "
    print success_num, "successfully installed"
    print failed_num, "failed"]]></script>
  </tool>

  <tool name="list_parm_templates" label="List Parm templates" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[
if len(hou.selectedNodes()) :
    selection = hou.selectedNodes()[0]
    for entry in selection.parmTemplateGroup().entries():
        print entry.label(),"_____________________________"
        for entry2 in entry.parmTemplates():
            print "\t",entry2
    
]]></script>
  </tool>

  <tool name="add_instance_point" label="Add instance point" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import sys
import toolutils
sceneViewer = toolutils.sceneViewer()
print sceneViewer
if hou.selectedNodes() :
    selection = hou.selectedNodes()[0]
    if selection.type().name() != 'instance' :
        hou.ui.displayMessage("the node must be of 'instance' type");
        sys.exit(0)
    
else : 
    selection = hou.node("/obj/").createNode("instance", "my_pick_node")
    print selection.children()
    

print sceneViewer.isOrientingOnSnap()
sceneViewer.setOrientOnSnap(1)
sceneViewer.selectPositions()[0]

]]></script>
  </tool>

  <tool name="find_opened_HDAs" label="find Opened HDAs" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[root = hou.node("/")
print len(root.allSubChildren())

unlockedHDAs = []
for node in root.allSubChildren():

    if node.type().definition() and node.isLockedHDA() == False:
#        print node.path()
        unlockedHDAs.append(node)
        
print len(unlockedHDAs)

print unlockedHDAs[0].path()]]></script>
  </tool>

  <tool name="ffmpeg_render" label="ffmpeg render" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import sys
import os
import subprocess
import re
# C:\Users\gui2one\Downloads\ffmpeg-20170125-2080bc3-win64-static\bin
ffmpegPath =  os.path.join("C:\\","Users","gui2one","Downloads","ffmpeg-20170125-2080bc3-win64-static","bin","ffmpeg.exe")
if not os.path.isfile(ffmpegPath):
    print "bad file"
    ffmpegPath = hou.ui.selectFile(file_type=hou.fileType.Any)
#    print ffmpegPath
    
    

sequencePath  = hou.ui.selectFile(
                                title='Select an image sequence',
                                file_type=hou.fileType.Any, 
                                collapse_sequences=True,
                                pattern="*")  
if sequencePath == '':
    sys.exit(0)

    
basename = os.path.basename(sequencePath)
fileName, ext = os.path.splitext(basename)
## find $F expression
regex = re.compile('\$F\d+', re.IGNORECASE)
to_replace = ''
numZeros = -1
for match in regex.finditer(fileName):
    # print "found -->",match.group(0)
    to_replace = match.group(0)
    numZeros = int(match.group(0).replace('$F',''))
    
dirPath = os.path.dirname(sequencePath)
# print "extension -->",ext
# print "dir path -->",dirPath

fileName = fileName.replace(to_replace,'%0'+str(numZeros)+'d')
fileName += ext

fullSource = os.path.join(dirPath,fileName).replace("\\","/")
# print "ffmpeg Path -->" , ffmpegPath

choice = hou.ui.displayMessage("add a soud file ?", buttons=('OK','Cancel'), close_choice=1, default_choice=1)

soundFile = ''
if choice == 0 : ## means 'ok'
    soundFile = hou.ui.selectFile(start_directory=hou.expandString('$HIP'), pattern="*.wav,*.mp3")
    # print "soundFile -->",soundFile
#sys.exit(0)

commandArray = []
commandArray.append(ffmpegPath)
commandArray.append('-i')
commandArray.append(fullSource)

if soundFile != '':
    commandArray.append('-i')
    commandArray.append(soundFile)   
    
commandArray.append('-b:v')    
commandArray.append('20000k')    
commandArray.append('-c:v')
commandArray.append('libx264')
commandArray.append('-preset')
commandArray.append('veryslow')
commandArray.append('D:/WORK/HOUDINI_16_5_playground/render/robotic_arm/aaa__01.mp4')

# subprocess.call([ffmpegPath, '-i',fullSource,'D:/WORK/HOUDINI_16_5_playground/render/robotic_arm/aaa__01.mp4'])
subprocess.call(commandArray)


print "DONE"]]></script>
  </tool>

  <tool name="osl_reload_script" label="osl reload script" icon="PLASMA_App">
    <toolMenuContext name="network">
      <contextNetType>SHOP</contextNetType>
      <contextNetType>VOP</contextNetType>
      <contextNetType>VOPNET</contextNetType>
    </toolMenuContext>
    <toolSubmenu>gui2one_scripts</toolSubmenu>
    <script scriptType="python"><![CDATA[sel = hou.selectedNodes()

if len(sel) == 1 :
    if sel[0].type().name() == 'octane::NT_TEX_OSL':
    
        parent = sel[0].parent()
        scriptPath = sel[0].parm('A_FILENAME').eval()
        name = sel[0].name()
        conn = sel[0].outputConnections()[0]
        outNode = conn.outputNode()
        inputIndex = conn.inputIndex()
        outputIndex = conn.outputIndex()        
        pos = sel[0].position()
        sel[0].destroy()
        
        newNode = parent.createNode('octane::NT_TEX_OSL', node_name=name)
        newNode.parm('A_FILENAME').set( scriptPath )
        newNode.setPosition( pos)
        
        outNode.setInput( inputIndex , newNode)
#         print conn.inputIndex()
        

        ]]></script>
  </tool>

  <tool name="HipLoader" label="Hip Loader" icon="hicon:/SVGIcons.index?BUTTONS_add_constraints.svg">
    <script scriptType="python"><![CDATA[import subprocess
import os

script_path = os.path.join("D:","CODE","HOUDINI_CONFIG", "hython","HipLoader.py")
print script_path
hcmd_path = os.path.join(hou.expandString('$HFS'),'bin','hcmd.exe')
hython_path = os.path.join(hou.expandString('$HFS'),'bin','hython.exe')
#cmd = hython_path
#cmd += ' '+ script_path
#cmd += ' && PAUSE'

#p = subprocess.Popen(hcmd_path+' -hython ', shell=False, stdin=subprocess.PIPE ,stdout=subprocess.PIPE, stderr=subprocess.PIPE) 
p = subprocess.Popen([hython_path, script_path], shell=False, bufsize=256, stdin=subprocess.PIPE ,stdout=subprocess.PIPE, stderr=subprocess.PIPE) 

output, error = p.communicate(b"communicating .... ' stdin")
rc = p.returncode
#
print "return Code :\n\t", rc
print "\nOUTPUT :\n\t", output
print "\nERROR :\n\t", error]]></script>
  </tool>

  <tool name="check_duplicate_inputs" label="Check for duplicate inputs" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[for sel in hou.selectedNodes():
    collection = []
    duplicatesIndices =  []
    inputs = sel.inputs()
    
    for i, input in enumerate(inputs):
        if input.name() in collection :
            print "duplicate at index", i
            duplicatesIndices.append(i)
        else : 
            collection.append(input.name())
            

            
    if len(duplicatesIndices) > 0:
        _str = "duplicates at index "
        for entry in duplicatesIndices :
            _str += str(entry)+","
        print _str
    else:
        print "no duplicate found"]]></script>
  </tool>

  <toolshelf name="destruction_V2" label="Destruction V2">
    <memberTool name="animated static attrs"/>
  </toolshelf>

  <tool name="animated static attrs" label="Animated Static Attrs" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import os
tools_path = hou.getenv("CUSTOM_PYTHON_TOOLS")
#print tools_path
if tools_path :
    path = os.path.join(tools_path, "destruction_V2/add_animated_static_attrs.py")
    execfile(path)
else :
    print "CUSTOM_PYTHON_TOOLS env variable missing chief !"
]]></script>
  </tool>

  <shelfSetEdit name="shelf_set_td" fileLocation="C:/PROGRA~1/SIDEEF~1/HOUDIN~1.405/houdini/toolbar\ShelfDefinitions.shelf">
    <addMemberToolshelf name="destruction" inPosition="16"/>
    <addMemberToolshelf name="destruction_V2" inPosition="17"/>
  </shelfSetEdit>
</shelfDocument>
